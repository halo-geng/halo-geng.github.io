<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode-DP-1</title>
    <link href="/2021/08/06/LeetCode-DP-1/"/>
    <url>/2021/08/06/LeetCode-DP-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 每日一题 August 1~10</title>
    <link href="/2021/08/01/LeetCode-August-1-10/"/>
    <url>/2021/08/01/LeetCode-August-1-10/</url>
    
    <content type="html"><![CDATA[<ul><li> 1 - 1337. 矩阵中战斗力最弱的 K 行；</li><li>August 1 - 1337. 矩阵中战斗力最弱的K行；</li><li>August 2 - </li><li>August 3 - </li><li>August 4 - </li><li>August 5 - </li><li>August 6 - </li><li>August 7 - </li><li>August 8 - </li><li>August 9 - </li><li>August 10 - </li></ul><span id="more"></span><hr><h3 id="August-1-1337-矩阵中战斗力最弱的K行"><a href="#August-1-1337-矩阵中战斗力最弱的K行" class="headerlink" title="August 1 - 1337. 矩阵中战斗力最弱的K行"></a>August 1 - 1337. 矩阵中战斗力最弱的K行</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p><p>请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。</p><p>如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。</p><p>军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：mat = <br>[[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]], <br>k = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]<br>解释：<br>每行中的军人数目：<br>行 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">2</span> <br>行 <span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> <br>行 <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> <br>行 <span class="hljs-number">3</span> -&gt; <span class="hljs-number">2</span> <br>行 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> <br>从最弱到最强对这些行排序后得到 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：mat = <br>[[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]], <br>k = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>解释： <br>每行中的军人数目：<br>行 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> <br>行 <span class="hljs-number">1</span> -&gt; <span class="hljs-number">4</span> <br>行 <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> <br>行 <span class="hljs-number">3</span> -&gt; <span class="hljs-number">1</span> <br>从最弱到最强对这些行排序后得到 [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>第一个能想到的解题思路是，先统计每一行 1 的个数，然后将结果进行排序，按照 1 的个数从小到大排序，如果 1 的个数相同，再按照行号从小到大排序。排好序的数组取出前 K 位即为答案。</p><p>此题还有第二种解法。在第一种解法中，并没有用到题目中“军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。”这一条件。由于有了这个条件，使得如果按照列去遍历，最先出现 0 的行，则是最弱的行。行号小的先被遍历到，所以相同数量 1 的行，行号小的会排在前面。最后记得再添加上全 1 的行。同样，最终输出取出前 K 位即为答案。此题解法二才是最优雅最高效的解法。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">kWeakestRows</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;temp;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mat.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j]==<span class="hljs-number">0</span> &amp;&amp; (j==<span class="hljs-number">0</span>||mat[i][j<span class="hljs-number">-1</span>]!=<span class="hljs-number">0</span>))&#123;<br>                    temp.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mat.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(mat[i][mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)&#123;<br>                temp.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(temp[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 每日一题 July 21~31</title>
    <link href="/2021/07/22/LeetCode-July-21-31/"/>
    <url>/2021/07/22/LeetCode-July-21-31/</url>
    
    <content type="html"><![CDATA[<ul><li>July 21 - 剑指 Offer 52. 两个链表的第一个公共节点；</li><li>July 22 - 138. 复制带随机指针的链表；</li></ul><span id="more"></span><hr><h3 id="July-21-剑指-Offer-52-两个链表的第一个公共节点"><a href="#July-21-剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="July 21 - 剑指 Offer 52. 两个链表的第一个公共节点"></a>July 21 - 剑指 Offer 52. 两个链表的第一个公共节点</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>输入两个链表，找出它们的第一个公共节点。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>示例1：</p><p><img src="/img/article/LeetCode/160_example_1.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">8</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">3</span><br>输出：Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">8</span><br>输入解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 A 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/img/article/LeetCode/160_example_3.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>输入解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针法</strong></p><p>使用双指针的方法，可以将空间复杂度降至 O(1)。</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><p>每步操作需要同时更新指针 pA 和 pB。</p><p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p><p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p><p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><p>下面提供双指针方法的正确性证明。考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。</p><p>情况一：两个链表相交</p><p>链表 headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m，b+c=n。</p><p>如果 a=b，则两个指针会同时到达两个链表的第一个公共节点，此时返回两个链表的第一个公共节点；</p><p>如果 a!=b，则指针 pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表的第一个公共节点，该节点也是两个指针第一次同时指向的节点，此时返回两个链表的第一个公共节点。</p><p>情况二：两个链表不相交</p><p>链表 headA 和 headB 的长度分别是 m 和 n。考虑当 m=n 和 m!=n 时，两个指针分别会如何移动：</p><p>如果 m=n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 null，此时返回 null；</p><p>如果 m!=n，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n 次、指针 pB 移动了 n+m 次之后，两个指针会同时变成空值 null，此时返回 null。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">NULL</span> || headB == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ListNode *pa = headA, *pb = headB;<br>            <span class="hljs-keyword">while</span>(pa!=pb)&#123;<br>                pa = pa == <span class="hljs-literal">NULL</span>?headB:pa-&gt;next;<br>                pb = pb == <span class="hljs-literal">NULL</span>?headA:pb-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> pa;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-22-138-复制带随机指针的链表"><a href="#July-22-138-复制带随机指针的链表" class="headerlink" title="July 22 - 138. 复制带随机指针的链表"></a>July 22 - 138. 复制带随机指针的链表</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的<strong>深拷贝</strong>。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><ul><li>val：一个表示 Node.val 的整数。</li><li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li></ul><p>你的代码只接受原链表的头节点 head 作为传入参数。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><p>示例1：</p><p><img src="/img/article/LeetCode/e1.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/img/article/LeetCode/e2.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><p><img src="/img/article/LeetCode/e3.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：回溯 + 哈希表</strong></p><p>本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p><p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p><p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p><p>时间复杂度：O(n)，其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</p><p>空间复杂度：O(n)，其中 n 是链表的长度。为哈希表的空间开销。</p><p><strong>方法二：map</strong></p><p>第一轮遍历构建旧链表和新链表的一一映射</p><p>第二轮遍历根据旧链表的next和random信息，补充新链表的next和random信息</p><p>时间复杂度：O(n)，空间复杂度：O(n)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一：回溯 + 哈希表</span><br><span class="hljs-comment">//执行用时8ms，内存消耗11.4MB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*,Node*&gt;map;<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!map.<span class="hljs-built_in">count</span>(head))&#123;<br>            Node *newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            map[head] = newHead;<br>            newHead-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            newHead-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> map[head];        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法二：map</span><br><span class="hljs-comment">//执行用时8ms，内存消耗11.1MB</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        Node *cur = head;<br>        unordered_map&lt;Node*,Node*&gt; map;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>            map[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>            map[cur]-&gt;next = map[cur-&gt;next];<br>            map[cur]-&gt;random = map[cur-&gt;random];<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hash</tag>
      
      <tag>Map</tag>
      
      <tag>Two-Point</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 21. 合并两个有序链表</title>
    <link href="/2021/07/20/Leetcode-21/"/>
    <url>/2021/07/20/Leetcode-21/</url>
    
    <content type="html"><![CDATA[<p>将两个升序链表合并为一个新的升序链表并返回。</p><span id="more"></span><hr><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><img src="/img/article/LeetCode/merge_ex1.jpg"></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：迭代</strong></p><p>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p><p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p><p><strong>方法二：递归</strong></p><p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：<br>$$<br>list1[0]+merge(list1[1:],list2)，list1[0]&lt;list2[0]<br>$$<br>$$<br>list2[0]+merge(list1,list2[1:])，otherwise<br>$$</p><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p><p>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//迭代</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* pre = ans;<br>        <span class="hljs-keyword">while</span>((l1!=<span class="hljs-literal">nullptr</span>)&amp;&amp;(l2!=<span class="hljs-literal">nullptr</span>))&#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;<br>                pre-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            pre = pre-&gt;next;<br>        &#125;<br>        pre-&gt;next = l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> ans-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1,l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort</tag>
      
      <tag>Linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 每日一题 July 11~20</title>
    <link href="/2021/07/11/LeetCode-July-11-20/"/>
    <url>/2021/07/11/LeetCode-July-11-20/</url>
    
    <content type="html"><![CDATA[<ul><li>July 11 - 274. H 指数；</li><li>July 12 - 275. H 指数 Ⅱ；</li><li>July 13 - 218. 天际线问题；</li><li>July 14 - 1818. 绝对差值和；</li><li>July 15 - 1846. 减小和重新排列数组后的最大元素；</li><li>July 16 - 剑指 Offer 53 - I. 在排序数组中查找数字 I；</li><li>July 17 - 剑指 Offer 42. 连续子数组的最大和；</li><li>July 18 - 面试题 10.02. 变位词组；</li><li>July 19 - 1838. 最高频元素的频数；</li><li>July 20 - 1877. 数组中最大数对和的最小值</li></ul><span id="more"></span><hr><h3 id="July-11-274-H-指数"><a href="#July-11-274-H-指数" class="headerlink" title="July 11 - 274. H 指数"></a>July 11 - 274. H 指数</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：citations = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">3</span> <br>解释：给定数组表示研究者总共有 <span class="hljs-number">5</span> 篇论文，每篇论文相应的被引用了 <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span> 次。<br>     由于研究者有 <span class="hljs-number">3</span> 篇论文每篇 至少 被引用了 <span class="hljs-number">3</span> 次，其余两篇论文每篇被引用 不多于 <span class="hljs-number">3</span> 次，所以她的 h 指数是 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">提示：如果 h 有多种可能的值，h 指数是其中最大的那个。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们可以将初始的 H 指数 h 设为 0，然后将引用次数排序，并且对排序后的数组从大到小遍历。</p><p>根据 H 指数的定义，如果当前 H 指数为 h 并且在遍历过程中找到当前值 citations[i]&gt;h，则说明我们找到了一篇被引用了至少 h+1 次的论文，所以将现有的 h 值加 1。继续遍历直到 h 无法继续增大。最后返回 h 作为最终答案。</p><p>时间复杂度：O(nlogn)，其中 n 为数组 citations 的长度。即为排序的时间复杂度。</p><p>空间复杂度：O(logn)，其中 n 为数组 citations 的长度。即为排序的空间复杂度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(citations.<span class="hljs-built_in">rbegin</span>(),citations.<span class="hljs-built_in">rend</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:citations)&#123;<br>            <span class="hljs-keyword">if</span>(a&gt;h)&#123;<br>                h++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-12-275-H-指数-Ⅱ"><a href="#July-12-275-H-指数-Ⅱ" class="headerlink" title="July 12 - 275. H 指数 Ⅱ"></a>July 12 - 275. H 指数 Ⅱ</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>这是 <a href="https://leetcode-cn.com/problems/h-index/description/">H 指数</a> 的延伸题目，本题中的 <code>citations</code> 数组是保证有序的。</p><p>优化算法到对数时间复杂度。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>由于数组 citations 已经按照升序排序，因此可以使用二分查找。</p><p>设查找范围的初始左边界 left 为 0, 初始右边界 right 为 n−1，其中 n 为数组 citations 的长度。每次在查找范围内取中点 mid，则有 n−mid 篇论文被引用了至少 citations[mid] 次。如果在查找过程中满足 citations[mid]≥n−mid，则移动右边界 right，否则移动左边界 left。</p><p>时间复杂度：O(logn)，其中 n 为数组 citations 的长度。二分查找的时间复杂度为 O(logn)。</p><p>空间复杂度：O(1)。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = citations.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (citations[mid] &gt;= n - mid) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-13-218-天际线问题"><a href="#July-13-218-天际线问题" class="headerlink" title="July 13 - 218. 天际线问题"></a>July 13 - 218. 天际线问题</h3><hr><h3 id="July-14-1818-绝对差值和"><a href="#July-14-1818-绝对差值和" class="headerlink" title="July 14 - 1818. 绝对差值和"></a>July 14 - 1818. 绝对差值和</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p><p>数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p><p>你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：<br>- 将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者<br>- 将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |<span class="hljs-string">1-2</span>|<span class="hljs-string"> + (</span>|<span class="hljs-string">1-3</span>|<span class="hljs-string"> 或者 </span>|<span class="hljs-string">5-3</span>|<span class="hljs-string">) + </span>|<span class="hljs-string">5-5</span>|<span class="hljs-string"> = 3</span><br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-symbol">nums1</span> 和 <span class="hljs-symbol">nums2</span> 相等，所以不用替换元素。绝对差值和为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]<br>输出：20<br>解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]<br>绝对差值和为 |<span class="hljs-string">10-9</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">10-3</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">4-5</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">4-1</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">2-7</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">7-4</span>|<span class="hljs-string"> = 20</span><br></code></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>排序 + 二分查找</strong></p><p><img src="/img/article/LeetCode/image-20210718163338527.png"></p><p>时间复杂度：O(nlogn)，其中 n 是数组 nums1 和 nums2 的长度。我们需要记录 nums 1 中的元素，并进行排序，时间复杂度是 O(nlogn)。计算 maxn 需要进行 n 次二分查找，每次二分查找的时间为 O(logn)，因此时间复杂度也是 O(nlogn)。所以总的时间复杂度为 O(nlogn)。</p><p>空间复杂度：O(n)，其中 n 是数组 nums 1和 nums 2 的长度。我们需要创建大小为 n 的辅助数组。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minAbsoluteSumDiff</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rec</span><span class="hljs-params">(nums1)</span></span>;<br>        <span class="hljs-built_in">sort</span>(rec.<span class="hljs-built_in">begin</span>(), rec.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> diff = <span class="hljs-built_in">abs</span>(nums1[i] - nums2[i]);<br>            sum = (sum + diff) % mod;<br>            <span class="hljs-keyword">int</span> j = <span class="hljs-built_in">lower_bound</span>(rec.<span class="hljs-built_in">begin</span>(), rec.<span class="hljs-built_in">end</span>(), nums2[i]) - rec.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">if</span> (j &lt; n) &#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, diff - (rec[j] - nums2[i]));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, diff - (nums2[i] - rec[j - <span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (sum - maxn + mod) % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-15-1846-减小和重新排列数组后的最大元素"><a href="#July-15-1846-减小和重新排列数组后的最大元素" class="headerlink" title="July 15 - 1846. 减小和重新排列数组后的最大元素"></a>July 15 - 1846. 减小和重新排列数组后的最大元素</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li>arr 中 第一个 元素必须为 1 。</li><li>任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 &lt;= i &lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) &lt;= 1 。abs(x) 为 x 的绝对值。</li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li>减小 arr 中任意元素的值，使其变为一个 更小的正整数 。</li><li>重新排列 arr 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。</p><h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[2,2,1,2,1]</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>我们可以重新排列 arr 得到 <span class="hljs-string">[1,2,2,2,1]</span> ，该数组满足所有条件。<br>arr 中最大元素为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：arr = [100,1,1000]<br>输出：3<br>解释：<br>一个可行的方案如下：<br><span class="hljs-bullet">1.</span> 重新排列 arr 得到 [1,100,1000] 。<br><span class="hljs-bullet">2.</span> 将第二个元素减小为 2 。<br><span class="hljs-bullet">3.</span> 将第三个元素减小为 3 。<br>现在 arr = [1,2,3] ，满足所有条件。<br>arr 中最大元素为 3 。<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">5</span><br>解释：数组已经满足所有条件，最大元素为 <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>排序 + 贪心</strong></p><p>提示 1</p><p>如果一个数组是满足要求的，那么将它的元素按照升序排序后得到的数组也是满足要求的。</p><p>提示 1 解释</p><p>假设数组中出现了元素 x 和 y，且 x&lt;y，由于相邻元素差值的绝对值小于等于 1，那么区间 [x,y] 内的所有整数应该都出现过。</p><p>只要我们令 x 和 y 分别为数组中元素的最小值和最大值，就说明了将数组升序排序后，得到的结果是不会出现「断层」的，也就是满足要求的。</p><p>提示 2</p><p>在提示 1 的基础上，我们得到了一个单调递增的数组。那么数组中相邻两个元素，要么后者等于前者，要么后者等于前者加上 1。</p><p>我们可以先将数组进行升序排序，随后对数组进行遍历，将 arr[i] 更新为其自身与 arr[i−1]+1 中的较小值即可。</p><p>最终的答案（最大值）即为 arr 中的最后一个元素。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumElementAfterDecrementingAndRearranging</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(arr[i+<span class="hljs-number">1</span>]-arr[i])&gt;<span class="hljs-number">1</span>)&#123;<br>                arr[i+<span class="hljs-number">1</span>] = arr[i] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-16-剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#July-16-剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="July 16 - 剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>July 16 - 剑指 Offer 53 - I. 在排序数组中查找数字 I</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>统计一个数字在排序数组中出现的次数。</p><h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>二分查找</strong></p><p>直观的思路肯定是从前往后遍历一遍。用两个变量记录第一次和最后一次遇见 target 的下标，但这个方法的时间复杂度为 O(n)，没有利用到数组升序排列的条件。</p><p>由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。</p><p>时间复杂度： O(logn) ，其中 n 为数组的长度。二分查找的时间复杂度为 O(logn)，一共会执行两次，因此总时间复杂度为 O(logn)。</p><p>空间复杂度：O(1) 。只需要常数空间存放若干变量。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> first = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">int</span> last = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">if</span>(first &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> last - first;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-17-剑指-Offer-42-连续子数组的最大和"><a href="#July-17-剑指-Offer-42-连续子数组的最大和" class="headerlink" title="July 17 - 剑指 Offer 42. 连续子数组的最大和"></a>July 17 - 剑指 Offer 42. 连续子数组的最大和</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>动态规划</strong></p><p><img src="/img/article/LeetCode/image-20210718172550964.png"></p><p>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</p><p>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> result = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;x:nums)&#123;<br>            pre = <span class="hljs-built_in">max</span>(x, pre+x);<br>            result = <span class="hljs-built_in">max</span>(result, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-18-面试题-10-02-变位词组"><a href="#July-18-面试题-10-02-变位词组" class="headerlink" title="July 18 - 面试题 10.02. 变位词组"></a>July 18 - 面试题 10.02. 变位词组</h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>],<br>输出:<br>[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br>说明：所有输入均为小写字母，不考虑答案输出的顺序。<br></code></pre></td></tr></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>两个字符串互为变位词，当且仅当两个字符串包含的字母相同。同一组变位词中的字符串具备相同点，可以使用相同点作为一组变位词的标志，使用哈希表存储每一组变位词，哈希表的键为一组变位词的标志，哈希表的值为一组变位词列表。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组变位词的标志，将当前字符串加入该组变位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组变位词。</p><p>由于互为变位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p><p>时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)。</p><p>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string,vector&lt;string&gt;&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str:strs)&#123;<br>            <span class="hljs-keyword">auto</span> tmpstr = str;<br>            <span class="hljs-built_in">sort</span>(tmpstr.<span class="hljs-built_in">begin</span>(),tmpstr.<span class="hljs-built_in">end</span>());<br>            map[tmpstr].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=map.<span class="hljs-built_in">begin</span>(); i!=map.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-19-1838-最高频元素的频数"><a href="#July-19-1838-最高频元素的频数" class="headerlink" title="July 19 - 1838. 最高频元素的频数"></a>July 19 - 1838. 最高频元素的频数</h3><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。</p><p>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。</p><h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">3</span><br>解释：对第一个元素执行 <span class="hljs-number">3</span> 次递增操作，对第二个元素执 <span class="hljs-number">2</span> 次递增操作，此时 <span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>] 。<br><span class="hljs-number">4</span> 是数组中最高频元素，频数是 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,4,8,13], k = 5<br>输出：2<br>解释：存在多种最优解决方案：<br>- 对第一个元素执行<span class="hljs-number"> 3 </span>次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br>- 对第二个元素执行<span class="hljs-number"> 4 </span>次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br>- 对第三个元素执行<span class="hljs-number"> 5 </span>次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>排序 + 滑动窗口</strong></p><p>提示 1</p><p>操作后的最高频元素必定可以是数组中已有的某一个元素。</p><p>提示 2</p><p>优先操作距离目标值最近的（小于目标值的）元素。</p><p>提示 3</p><p>遍历数组中的每个元素作为目标值并进行尝试。此处是否存在一些可以用于优化算法的性质？</p><p><strong>思路与算法</strong></p><p><img src="/img/article/LeetCode/image-20210801165436134.png"></p><p>时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。排序数组的时间复杂度为 O(nlogn)，使用滑动窗口遍历目标值的时间复杂度为 O(n)。</p><p>空间复杂度：O(logn)，即为排序数组需要使用的栈空间。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//时间超限</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxFrequency</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>                <span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> tempk = k;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                    tempk -= (nums[i] - nums[j]);<br>                    <span class="hljs-keyword">if</span>(tempk&gt;=<span class="hljs-number">0</span>)&#123;  <br>                        temp++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp&gt;max)&#123;<br>                    max = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxFrequency</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>; r &lt; n; ++r) &#123;<br>            total += (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(nums[r] - nums[r - <span class="hljs-number">1</span>]) * (r - l);<br>            <span class="hljs-keyword">while</span> (total &gt; k) &#123;<br>                total -= nums[r] - nums[l];<br>                ++l;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-20-1877-数组中最大数对和的最小值"><a href="#July-20-1877-数组中最大数对和的最小值" class="headerlink" title="July 20 - 1877. 数组中最大数对和的最小值"></a>July 20 - 1877. 数组中最大数对和的最小值</h3><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h4><p>一个数对 (a,b) 的 <strong>数对和</strong> 等于 a + b 。<strong>最大数对和</strong> 是一个数对数组中最大的 数对和 。</p><ul><li>比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。</li></ul><p>给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：</p><ul><li>nums 中每个元素 恰好 在 一个 数对中，且</li><li>最大数对和 的值 最小 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 最大数对和 。</p><h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">7</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) 和 (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span><span class="hljs-operator">+</span><span class="hljs-number">3</span>, <span class="hljs-number">5</span><span class="hljs-operator">+</span><span class="hljs-number">2</span>) <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>) <span class="hljs-operator">=</span> <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">8</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)，(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) 和 (<span class="hljs-number">6</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span><span class="hljs-operator">+</span><span class="hljs-number">5</span>, <span class="hljs-number">4</span><span class="hljs-operator">+</span><span class="hljs-number">4</span>, <span class="hljs-number">6</span><span class="hljs-operator">+</span><span class="hljs-number">2</span>) <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>) <span class="hljs-operator">=</span> <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>排序 + 贪心</strong></p><p>提示 1</p><p>数组内只有两个数的情况是平凡的。我们可以考虑数组中只有四个数 x1≤x2≤x3≤x4 的情况。此时 (x1,x4),(x2,x3) 的拆分方法对应的最大数对和一定是最小的。</p><p>提示 2</p><p>对于 n 个数（n 为偶数）的情况，上述的条件对应的拆分方法，即第 kk 大与第 kk 小组成的 n / 2n/2 个数对，同样可以使得最大数对和最小。</p><p>根据 提示 2，我们需要将 nums 排序。排序后，我们遍历每一个第 k 大与第 k 小组成的数对，计算它们的和，并维护这些和的最大值。同样根据 提示 2，遍历完成后求得的最大数对和就是满足要求的最小值。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPairSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max &lt; nums[i]+nums[n-i<span class="hljs-number">-1</span>])&#123;<br>                max = nums[i]+nums[n-i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hash</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Greedy</tag>
      
      <tag>Sort</tag>
      
      <tag>Binary Search</tag>
      
      <tag>Sliding Window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 每日一题 July 1~10</title>
    <link href="/2021/07/04/LeetCode-July-1-10/"/>
    <url>/2021/07/04/LeetCode-July-1-10/</url>
    
    <content type="html"><![CDATA[<ul><li>July 1 - LCP 07. 传递信息；</li><li>July 2 - 1833. 雪糕的最大数量；</li><li>July 3 - 根据字符出现频率排序；</li><li>July 4 - 645. 错误的集合；</li><li>July 5 - 726. 原子的数量；</li><li>July 6 - 1418. 点菜展示表；</li><li>July 7 - 1711. 大餐计数；</li><li>July 8 - 930. 和相同的二元子数组；</li><li>July 9 - 面试题 17.10. 主要元素；</li><li>July 10 - 981. 基于时间的键值存储</li></ul><span id="more"></span><hr><h3 id="July-1-LCP-07-传递信息"><a href="#July-1-LCP-07-传递信息" class="headerlink" title="July 1 - LCP 07. 传递信息"></a>July 1 - LCP 07. 传递信息</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ul><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ul><p>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：n = <span class="hljs-number">5</span>, relation = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>说明：信息从小 A 编号 <span class="hljs-number">0</span> 处开始，经 <span class="hljs-number">3</span> 轮传递，到达编号 <span class="hljs-number">4</span>。共有 <span class="hljs-number">3</span> 种方案，分别是 <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：n = <span class="hljs-number">3</span>, relation = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">限制：<br>    <span class="hljs-number">2</span> &lt;= n &lt;= <span class="hljs-number">10</span><br><span class="hljs-number">1</span> &lt;= k &lt;= <span class="hljs-number">5</span><br><span class="hljs-number">1</span> &lt;= relation.length &lt;= <span class="hljs-number">90</span>, 且 relation[i].length == <span class="hljs-number">2</span><br><span class="hljs-number">0</span> &lt;= relation[i][<span class="hljs-number">0</span>],relation[i][<span class="hljs-number">1</span>] &lt; n 且 relation[i][<span class="hljs-number">0</span>] != relation[i][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h5><p>可以把传信息的关系看成有向图，每个玩家对应一个节点，每个传信息的关系对应一条有向边。如果 x 可以向 y 传信息，则对应从节点 x 到节点 y 的一条有向边。寻找从编号 0 的玩家经过 k 轮传递到编号 n−1 的玩家处的方案数，等价于在有向图中寻找从节点 0 到节点 n−1 的长度为 k 的路径数，同一条路径可以重复经过同一个节点。</p><p>可以使用深度优先搜索计算方案数。从节点 0 出发做深度优先搜索，每一步记录当前所在的节点以及经过的轮数，当经过 k 轮时，如果位于节点 n−1，则将方案数加 1。搜索结束之后，即可得到总的方案数。</p><p>时间复杂度：O(n^k)。最多需要遍历 k 层，每层遍历最多有 O(n) 个分支。</p><p>空间复杂度：O(n+m+k)。其中 m 为 relation 数组的长度。空间复杂度主要取决于图的大小和递归调用栈的深度，保存有向图信息所需空间为 O(n+m)，递归调用栈的深度不会超过 k。</p><h5 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h5><p>也可以使用广度优先搜索计算方案数。从节点 0 出发做广度优先搜索，当遍历到 k 层时，如果位于节点 n−1，则将方案数加 1。搜索结束之后，即可得到总的方案数。</p><h5 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h5><p>这道题是计数问题，可以使用动态规划的方法解决。</p><p>定义动态规划的状态 dp[i][j]为经过 i 轮传递到编号 j 的玩家的方案数，其中 0≤i≤k，0≤j&lt;n。</p><p>由于从编号 0 的玩家开始传递，当 i=0 时，一定位于编号 0 的玩家，不会传递到其他玩家，因此动态规划的边界情况如下：</p><p><img src="/img/article/LeetCode/image-20210701213904825.png"></p><p>对于传信息的关系 [src,dst]，如果第 i轮传递到编号 src 的玩家，则第 i+1 轮可以从编号 src 的玩家传递到编号 dst 的玩家。因此在计算 dp[i+1][dst] 时，需要考虑可以传递到编号 dst 的所有玩家。由此可以得到动态规划的状态转移方程，其中 0≤i&lt;k：</p><p><img src="/img/article/LeetCode/image-20210701214033003.png"></p><p>最终得到 dp[k][n−1] 即为总的方案数。</p><p>时间复杂度：O(km)。其中 m为 relation 数组的长度。</p><p>空间复杂度是 O(kn)。由于当 i&gt;0 时，dp[i][] 的值只和dp[i−1][] 的值有关，因此可以将二维数组变成一维数组，将空间复杂度优化到 O(n)。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//动态规划</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : relation) &#123;<br>                <span class="hljs-keyword">int</span> src = edge[<span class="hljs-number">0</span>], dst = edge[<span class="hljs-number">1</span>];<br>                dp[i + <span class="hljs-number">1</span>][dst] += dp[i][src];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//动态规划空间复杂度优化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : relation) &#123;<br>                <span class="hljs-keyword">int</span> src = edge[<span class="hljs-number">0</span>], dst = edge[<span class="hljs-number">1</span>];<br>                next[dst] += dp[src];<br>            &#125;<br>            dp = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析 | 菜鸟教程 (runoob.com)</a></p><hr><h3 id="July-2-1833-雪糕的最大数量"><a href="#July-2-1833-雪糕的最大数量" class="headerlink" title="July 2 - 1833. 雪糕的最大数量"></a>July 2 - 1833. 雪糕的最大数量</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>排序 + 贪心</p><p>对数组costs 排序，然后按照从小到大的顺序遍历数组元素，对于每个元素，如果该元素不超过剩余的硬币数，则将硬币数减去该元素值，表示购买了这支雪糕，当遇到一个元素超过剩余的硬币数时，结束遍历，此时购买的雪糕数量即为可以购买雪糕的最大数量。</p><p>时间复杂度：O(nlogn)，其中 n 是数组 costs 的长度。对数组排序的时间复杂度是 O(nlogn)，遍历数组的时间复杂度是O(n)，因此总时间复杂度是O(nlogn)。</p><p>空间复杂度：O(logn)，其中 n 是数组 costs 的长度。空间复杂度主要取决于排序使用的额外空间。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxIceCream</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; costs, <span class="hljs-keyword">int</span> coins)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(costs.<span class="hljs-built_in">begin</span>(),costs.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a : costs)&#123;<br>            <span class="hljs-keyword">if</span>(a&lt;=coins)&#123;<br>                i++;<br>                coins-=a;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-3-根据字符出现频率排序"><a href="#July-3-根据字符出现频率排序" class="headerlink" title="July 3 - 根据字符出现频率排序"></a>July 3 - 根据字符出现频率排序</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入:<br><span class="hljs-string">&quot;tree&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;eert&quot;</span><br><br>解释:<br><span class="hljs-string">&#x27;e&#x27;</span>出现两次，<span class="hljs-string">&#x27;r&#x27;</span>和<span class="hljs-string">&#x27;t&#x27;</span>都只出现一次。<br>因此<span class="hljs-string">&#x27;e&#x27;</span>必须出现在<span class="hljs-string">&#x27;r&#x27;</span>和<span class="hljs-string">&#x27;t&#x27;</span>之前。此外，<span class="hljs-string">&quot;eetr&quot;</span>也是一个有效的答案。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入:<br><span class="hljs-string">&quot;Aabb&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;bbAa&quot;</span><br><br>解释:<br>此外，<span class="hljs-string">&quot;bbaA&quot;</span>也是一个有效的答案，但<span class="hljs-string">&quot;Aabb&quot;</span>是不正确的。<br>注意<span class="hljs-string">&#x27;A&#x27;</span>和<span class="hljs-string">&#x27;a&#x27;</span>被认为是两种不同的字符。<br></code></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题目要求将给定的字符串按照字符出现的频率降序排序，因此需要首先遍历字符串，统计每个字符出现的频率，然后每次得到频率最高的字符，生成排序后的字符串。</p><p>可以使用哈希表记录每个字符出现的频率，将字符去重后存入列表，再将列表中的字符按照频率降序排序。</p><p>生成排序后的字符串时，遍历列表中的每个字符，则遍历顺序为字符按照频率递减的顺序。对于每个字符，将该字符按照出现频率拼接到排序后的字符串。例如，遍历到字符 c，该字符在字符串中出现了 freq 次，则将 freq 个字符 c 拼接到排序后的字符串。</p><p>时间复杂度：O(n+klogk)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数，这道题中 s 只包含大写字母、小写字母和数字，因此 k=26+26+10=62。遍历字符串统计每个字符出现的频率需要 O(n) 的时间。将字符按照出现频率排序需要 O(klogk) 的时间。生成排序后的字符串，需要遍历 k 个不同字符，需要 O(k) 的时间，拼接字符串需要 O(n) 的时间。因此总时间复杂度是 O(n+klogk+k+n)=O(n+klogk)。</p><p>空间复杂度：O(n+k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于哈希表、列表和生成的排序后的字符串。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;a, pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;freq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m:s)&#123;<br>            freq[m]++;<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;&gt;vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:freq)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(n);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),cmp);<br>        string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:vec)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k.second;i++)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(k.first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>reference to non-static member function must be called</p><p><a href="https://blog.csdn.net/u010982765/article/details/79021426">错误：reference to non-static member function must be called_initHeart的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/AnnieKim/archive/2011/12/04/2275589.html">恼人的函数指针（二）：指向类成员的指针 - AnnieKim - 博客园 (cnblogs.com)</a></p></blockquote><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/xs18952904/article/details/81463822">C++中 sort() 的使用_LucienShui-CSDN博客</a></p><p><a href="https://blog.csdn.net/sevenjoin/article/details/81937695">C++ pair的基本用法总结（整理）_sevenjoin的博客-CSDN博客_c++ pair</a></p><p><a href="https://blog.csdn.net/hk2291976/article/details/51037095">关联容器：unordered_map详细介绍（附可运行代码）_Voidsky-CSDN博客</a></p><p><a href="http://c.biancheng.net/view/6826.html">C++ STL vector添加元素（push_back()和emplace_back()）详解 (biancheng.net)</a></p><hr><h3 id="July-4-645-错误的集合"><a href="#July-4-645-错误的集合" class="headerlink" title="July 4 - 645. 错误的集合"></a>July 4 - 645. 错误的集合</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。</p><p>给定一个数组 nums 代表了集合 S 发生错误后的结果。</p><p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2,4]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,3,4,6,5]</span><br>输出：<span class="hljs-comment">[3,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,5,3,2</span>,<span class="hljs-number">2,7,6,4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：排序</strong></p><p>将数组排序之后，比较每对相邻的元素，即可找到错误的集合。</p><p>寻找重复的数字较为简单，如果相邻的两个元素相等，则该元素为重复的数字。</p><p>寻找丢失的数字相对复杂，可能有以下两种情况：</p><ul><li>如果丢失的数字大于 1 且小于 n，则一定存在相邻的两个元素的差等于 2，这两个元素之间的值即为丢失的数字；</li><li>如果丢失的数字是 1 或 n，则需要另外判断。</li></ul><p>时间复杂度：O(nlogn)，其中 nn 是数组 nums 的长度。排序需要 O(nlogn) 的时间，遍历数组找到错误的集合需要 O(n) 的时间，因此总时间复杂度是 O(nlogn)。</p><p>空间复杂度：O(logn)，其中 n 是数组 nums 的长度。排序需要 O(logn) 的空间。</p><p><strong>方法二：哈希表</strong></p><p>重复的数字在数组中出现 2 次，丢失的数字在数组中出现 0 次，其余的每个数字在数组中出现 1 次。因此可以使用哈希表记录每个元素在数组中出现的次数，然后遍历从 1 到 n 的每个数字，分别找到出现 2 次和出现 0 次的数字，即为重复的数字和丢失的数字。</p><p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。需要遍历数组并填入哈希表，然后遍历从 1 到 n 的每个数寻找错误的集合。</p><p>空间复杂度：O(n)，其中 n 是数组nums 的长度。需要创建大小为 O(n) 的哈希表。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法1，排序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">int</span> curr = nums[i];<br>            <span class="hljs-keyword">if</span>(curr == prev)&#123;<br>                result[<span class="hljs-number">0</span>] = prev;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curr - prev &gt; <span class="hljs-number">1</span>)&#123;<br>                result[<span class="hljs-number">1</span>] = curr - <span class="hljs-number">1</span>;<br>            &#125;<br>            prev = curr;<br>        &#125; <br>        <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>] != n)&#123;<br>            result[<span class="hljs-number">1</span>] = n;<br>        &#125;       <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法2，hash表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;num_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:nums)&#123;<br>            num_map[i]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(num_map[j] == <span class="hljs-number">0</span>)&#123;<br>                result[<span class="hljs-number">1</span>] = j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num_map[j] == <span class="hljs-number">2</span>)&#123;<br>                result[<span class="hljs-number">0</span>] = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li>注意数组边界，前后两个数字相比时，注意后面一个数字不要越界</li><li>注意特殊情况，当缺少1或者n时的特殊处理</li></ul><hr><h3 id="July-5-726-原子的数量"><a href="#July-5-726-原子的数量" class="headerlink" title="July 5 - 726. 原子的数量"></a>July 5 - 726. 原子的数量</h3><hr><h3 id="July-6-1418-点菜展示表"><a href="#July-6-1418-点菜展示表" class="headerlink" title="July 6 - 1418. 点菜展示表"></a>July 6 - 1418. 点菜展示表</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。</p><p>请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">displayTable</span>(vector&lt;vector&lt;string&gt;&gt; &amp;orders) &#123;<br>        <span class="hljs-comment">// 从订单中获取餐品名称和桌号，统计每桌点餐数量</span><br>        unordered_set&lt;string&gt; nameSet;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt;&gt; foodsCnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;order : orders) &#123;<br>            nameSet.<span class="hljs-built_in">insert</span>(order[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">int</span> id = <span class="hljs-built_in">stoi</span>(order[<span class="hljs-number">1</span>]);<br>            ++foodsCnt[id][order[<span class="hljs-number">2</span>]];<br>        &#125;<br><br>        <span class="hljs-comment">// 提取餐品名称，并按字母顺序排列</span><br>        <span class="hljs-keyword">int</span> n = nameSet.<span class="hljs-built_in">size</span>();<br>        vector&lt;string&gt; names;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;name : nameSet) &#123;<br>            names.<span class="hljs-built_in">push_back</span>(name);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(names.<span class="hljs-built_in">begin</span>(), names.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">// 提取桌号，并按餐桌桌号升序排列</span><br>        <span class="hljs-keyword">int</span> m = foodsCnt.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ids;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[id, _] : foodsCnt) &#123;<br>            ids.<span class="hljs-built_in">push_back</span>(id);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(ids.<span class="hljs-built_in">begin</span>(), ids.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">// 填写点菜展示表</span><br>        vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">table</span>(m + <span class="hljs-number">1</span>, vector&lt;string&gt;(n + <span class="hljs-number">1</span>));<br>        table[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Table&quot;</span>;<br>        <span class="hljs-built_in">copy</span>(names.<span class="hljs-built_in">begin</span>(), names.<span class="hljs-built_in">end</span>(), table[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">int</span> id = ids[i];<br>            <span class="hljs-keyword">auto</span> &amp;cnt = foodsCnt[id];<br>            table[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">to_string</span>(id);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                table[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">to_string</span>(cnt[names[j]]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> table;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-7-1711-大餐计数"><a href="#July-7-1711-大餐计数" class="headerlink" title="July 7 - 1711. 大餐计数"></a>July 7 - 1711. 大餐计数</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 任意 两道餐品做一顿大餐。</p><p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为<span class="hljs-number"> 4 </span>、8 、8 和<span class="hljs-number"> 16 </span>，都是<span class="hljs-number"> 2 </span>的幂。<br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为<span class="hljs-number"> 3 </span>种 (1,1) ，9 种 (1,3) ，和<span class="hljs-number"> 3 </span>种 (1,7) 。<br></code></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>朴素的解法是遍历数组 deliciousness 中的每对元素，对于每对元素，计算两个元素之和是否等于 2 的幂。该解法的时间复杂度为 O(n^2)，会超出时间限制。</p><p>上述朴素解法存在同一个元素被重复计算的情况，因此可以使用哈希表减少重复计算，降低时间复杂度。具体做法是，使用哈希表存储数组中的每个元素的出现次数，遍历到数组 deliciousness 中的某个元素时，在哈希表中寻找与当前元素的和等于 2 的幂的元素个数，然后用当前元素更新哈希表。由于遍历数组时，哈希表中已有的元素的下标一定小于当前元素的下标，因此任意一对元素之和等于 2 的幂的元素都不会被重复计算。</p><p>令 maxVal 表示数组 deliciousness 中的最大元素，则数组中的任意两个元素之和都不会超过   maxVal×2。令 maxSum=maxVal×2，则任意一顿大餐的美味程度之和为不超过 maxSum 的某个 2 的幂。</p><p>对于某个特定的 2 的幂 sum，可以在 O(n) 的时间内计算数组 deliciousness 中元素之和等于 sum 的元素对的数量。数组 deliciousness 中的最大元素 maxVal 满足 maxVal≤C，其中 C=2^20，则不超过 maxSum 的 2 的幂有 O(logmaxSum)=O(logmaxVal)=O(logC) 个，因此可以在 O(nlogC) 的时间内计算数组 deliciousness 中的大餐数量。</p><p>时间复杂度：O(nlogC)，其中 n 是数组 deliciousness 的长度，C 是数组 deliciousness 中的元素值上限，这道题中 C=2^20 。需要遍历数组 deliciousness 一次，对于其中的每个元素，需要 O(logC) 的时间计算包含该元素的大餐数量，因此总时间复杂度是 O(nlogC)。</p><p>空间复杂度：O(n)，其中 n 是数组 deliciousness 的长度。需要创建哈希表，哈希表的大小不超过 n。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; deliciousness)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxVal =  *<span class="hljs-built_in">max_element</span>(deliciousness.<span class="hljs-built_in">begin</span>(),deliciousness.<span class="hljs-built_in">end</span>());  <br>        <span class="hljs-keyword">int</span> maxSum = maxVal * <span class="hljs-number">2</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:deliciousness)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=<span class="hljs-number">1</span>; sum&lt;=maxSum; sum*=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">int</span> num = map.<span class="hljs-built_in">count</span>(sum-a)? map[sum-a]:<span class="hljs-number">0</span>;<br>                result = (result + num) % MOD;<br>            &#125;<br>            map[a]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/sevenjoin/article/details/81943864">C++ map用法总结（整理）_sevenjoin的博客-CSDN博客_c++map</a></li><li><a href="https://www.cnblogs.com/sword-/p/8036813.html">C++中Vector求最大值最小值 - 西瓜刀刀刀 - 博客园 (cnblogs.com)</a></li></ul><hr><h3 id="July-8-930-和相同的二元子数组"><a href="#July-8-930-和相同的二元子数组" class="headerlink" title="July 8 - 930. 和相同的二元子数组"></a>July 8 - 930. 和相同的二元子数组</h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,0,1,0,1]</span>, goal = 2<br>输出：4<br>解释：有 4 个满足题目要求的子数组：<span class="hljs-comment">[1,0,1]</span>、<span class="hljs-comment">[1,0,1,0]</span>、<span class="hljs-comment">[0,1,0,1]</span>、<span class="hljs-comment">[1,0,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-attr">goal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：哈希表</strong></p><p>假设原数组的前缀和数组为 sum，且子数组 (i,j] 的区间和为 goal，那么 sum[j]−sum[i]=goal。因此我们可以枚举 j ，每次查询满足该等式的 i 的数量。</p><p>具体地，我们用哈希表记录每一种前缀和出现的次数，假设我们当前枚举到元素 nums[j]，我们只需要查询哈希表中元素 sum[j]−goal 的数量即可，这些元素的数量即对应了以当前 j 值为右边界的满足条件的子数组的数量。最后这些元素的总数量即为所有和为 goal 的子数组数量。</p><p>在实际代码中，我们实时地更新哈希表，以防止出现 i≥j 的情况。</p><p>时间复杂度：O(n)，其中 n 为给定数组的长度。对于数组中的每个元素，我们至多只需要插入到哈希表中中一次。</p><p>空间复杂度：O(n)，其中 n 为给定数组的长度。哈希表中至多只存储 O(n) 个元素。</p><p><strong>方法二：滑动窗口</strong></p><p>注意到对于方法一中每一个 j，满足 sum[j]−sum[i]=goal 的 i 总是落在一个连续的区间中，i 值取区间中每一个数都满足条件。并且随着 j 右移，其对应的区间的左右端点也将右移，这样我们即可使用滑动窗口解决本题。</p><p>具体地，我们令滑动窗口右边界为 right，使用两个左边界 left1 和 left2 表示左区间 [left1 ,left2)，此时有 left2−left1 个区间满足条件。</p><p>在实际代码中，我们需要注意 left1≤left2≤right+1，因此需要在代码中限制 left1和 left2 不超出范围。</p><p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为给定数组的长度。我们至多只需要遍历一次该数组。</p><p>空间复杂度：<em>O</em>(1)，我们只需要常数的空间保存若干变量。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一：哈希表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarraysWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums)&#123;<br>            map[sum]++;<br>            sum += a;<br>            result += map[sum-goal];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法二：滑动窗口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarraysWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> left1 = <span class="hljs-number">0</span>, left2 = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum1 = <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            sum1 += nums[right];<br>            <span class="hljs-keyword">while</span> (left1 &lt;= right &amp;&amp; sum1 &gt; goal) &#123;<br>                sum1 -= nums[left1];<br>                left1++;<br>            &#125;<br>            sum2 += nums[right];<br>            <span class="hljs-keyword">while</span> (left2 &lt;= right &amp;&amp; sum2 &gt;= goal) &#123;<br>                sum2 -= nums[left2];<br>                left2++;<br>            &#125;<br>            ret += left2 - left1;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-9-面试题-17-10-主要元素"><a href="#July-9-面试题-17-10-主要元素" class="headerlink" title="July 9 - 面试题 17.10. 主要元素"></a>July 9 - 面试题 17.10. 主要元素</h3><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><p>数组中占比<strong>超过一半</strong>的元素称之为<strong>主要元素</strong>。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。</p><h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,2,5,9</span>,<span class="hljs-number">5,9,5,5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,2]</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">输入：<span class="hljs-selector-attr">[2,2,2,3,3,4,4]</span><br>输出：<span class="hljs-selector-tag">-1</span> (元素<span class="hljs-number">2</span>的个数没有超过一半)<br></code></pre></td></tr></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>由于题目要求时间复杂度 O(n) 和空间复杂度 O(1)，因此符合要求的解法只有 Boyer-Moore 投票算法。</p><p>Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。</p><p>如果数组为空，则数组中不存在主要元素；</p><p>如果数组中剩下的元素都相等，则数组中剩下的元素可能为主要元素。</p><p>Boyer-Moore 投票算法的步骤如下：</p><p>维护一个候选主要元素 candidate 和候选主要元素的出现次数 count，初始时 candidate 为任意值，count=0；</p><p>遍历数组 nums 中的所有元素，遍历到元素 x 时，进行如下操作：</p><p>如果 count=0，则将 x 的值赋给 candidate，否则不更新 candidate 的值；</p><p>如果 x=candidate，则将 count 加 1，否则将 count 减 1。</p><p>遍历结束之后，如果数组 nums 中存在主要元素，则 candidate 即为主要元素，否则 candidate 可能为数组中的任意一个元素。</p><p>由于不一定存在主要元素，因此需要第二次遍历数组，验证 candidate 是否为主要元素。第二次遍历时，统计 candidate 在数组中的出现次数，如果出现次数大于数组长度的一半，则 candidate 是主要元素，返回 candidate，否则数组中不存在主要元素，返回 −1。</p><p>为什么当数组中存在主要元素时，Boyer-Moore 投票算法可以确保得到主要元素？</p><p>在 Boyer-Moore 投票算法中，遇到相同的数则将 count 加 1，遇到不同的数则将 count 减 1。根据主要元素的定义，主要元素的出现次数大于其他元素的出现次数之和，因此在遍历过程中，主要元素和其他元素两两抵消，最后一定剩下至少一个主要元素，此时 candidate 为主要元素，且 count≥1。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通解法O(n),O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">int</span> max = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:nums)&#123;<br>            map[a]++;<br>            <span class="hljs-keyword">if</span>(map[a] &gt; max)&#123;<br>                result = a;<br>                max = map[a];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Boyer-Moore 投票算法 O(n),O(1)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums)&#123;<br>            <span class="hljs-keyword">if</span>((count==<span class="hljs-number">0</span>)&amp;&amp;(a!=candidate))&#123;<br>                candidate=a;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == candidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                count--;<br>            &#125;<br>        &#125;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b:nums)&#123;<br>            <span class="hljs-keyword">if</span>(b==candidate)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count&gt;nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> candidate;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><p><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/solution/zhu-yao-yuan-su-by-leetcode-solution-xr1p/">主要元素 - 主要元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><hr><h3 id="July-10-981-基于时间的键值存储"><a href="#July-10-981-基于时间的键值存储" class="headerlink" title="July 10 - 981. 基于时间的键值存储"></a>July 10 - 981. 基于时间的键值存储</h3><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h4><p>创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：</p><ol><li><p>set(string key, string value, int timestamp)</p><ul><li>存储键 key、值 value，以及给定的时间戳 timestamp。</li></ul></li><li><p>get(string key, int timestamp)</p><ul><li>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。</li><li>如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。</li><li>如果没有值，则返回空字符串（””）。</li></ul></li></ol><h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：inputs = [<span class="hljs-string">&quot;TimeMap&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>], inputs = [[],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">3</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar2&quot;</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">5</span>]]<br>输出：[null,null,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,null,<span class="hljs-string">&quot;bar2&quot;</span>,<span class="hljs-string">&quot;bar2&quot;</span>]<br>解释：  <br>TimeMap kv;   <br>kv.set(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 存储键 <span class="hljs-string">&quot;foo&quot;</span> 和值 <span class="hljs-string">&quot;bar&quot;</span> 以及时间戳 timestamp = <span class="hljs-number">1</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>);  <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar&quot;</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar&quot;</span> 因为在时间戳 <span class="hljs-number">3</span> 和时间戳 <span class="hljs-number">2</span> 处没有对应 <span class="hljs-string">&quot;foo&quot;</span> 的值，所以唯一的值位于时间戳 <span class="hljs-number">1</span> 处（即 <span class="hljs-string">&quot;bar&quot;</span>）   <br>kv.set(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar2&quot;</span>, <span class="hljs-number">4</span>);   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar2&quot;</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar2&quot;</span>  <br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：inputs = [<span class="hljs-string">&quot;TimeMap&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>], inputs = [[],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-number">10</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>,<span class="hljs-number">20</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">5</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">10</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">15</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">20</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">25</span>]]<br>输出：[null,null,null,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">提示：所有 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeMap</span>.</span></span>set 操作中的时间戳 timestamps 都是严格递增的。<br></code></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>哈希表 + 二分查找</strong></p><p>为实现 get 操作，我们需要用一个哈希表存储 set 操作传入的数据。具体地，哈希表的键为字符串 key，值为一个二元组列表，二元组中存储的是时间戳 timestamp 和值 value。</p><p>由于 set 操作中的时间戳都是严格递增的，因此二元组列表中保存的时间戳也是严格递增的，这样我们可以根据 get 操作中的 key 在哈希表中找到对应的二元组列表 pairs，然后根据 timestamp 在 pairs 中二分查找。我们需要找到最大的不超过 timestamp 的时间戳，对此，我们可以二分找到第一个超过 timestamp 的二元组下标 i，若 i&gt;0 则说明目标二元组存在，即 pairs[i−1]，否则二元组不存在，返回空字符串。</p><p>时间复杂度：</p><ul><li>初始化 TimeMap 和 set 操作均为 O(1)；</li><li>get 操作为 O(logn)，其中 n 是 set 操作的次数。最坏情况下 set 操作插入的 key 均相同，这种情况下 get 中二分查找的次数为 O(logn)。</li></ul><p>空间复杂度：O(n)，其中 n 是 set 操作的次数。我们需要使用哈希表保存每一次 set 操作的信息。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeMap</span> &#123;</span><br>    unordered_map&lt;string, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, string&gt;&gt;&gt; m;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeMap</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(string key, string value, <span class="hljs-keyword">int</span> timestamp)</span> </span>&#123;<br>        m[key].<span class="hljs-built_in">emplace_back</span>(timestamp, value);<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(string key, <span class="hljs-keyword">int</span> timestamp)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> &amp;pairs = m[key];<br>        <span class="hljs-comment">// 使用一个大于所有 value 的字符串</span><br>        <span class="hljs-comment">// 以确保在 pairs 中含有 timestamp 的情况下也返回大于 timestamp 的位置</span><br>        pair&lt;<span class="hljs-keyword">int</span>, string&gt; p = &#123;timestamp, <span class="hljs-built_in">string</span>(&#123;<span class="hljs-number">127</span>&#125;)&#125;;<br>        <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">upper_bound</span>(pairs.<span class="hljs-built_in">begin</span>(), pairs.<span class="hljs-built_in">end</span>(), p);<br>        <span class="hljs-keyword">if</span> (i != pairs.<span class="hljs-built_in">begin</span>()) &#123;<br>            <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>)-&gt;second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hash</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Greedy</tag>
      
      <tag>Sort</tag>
      
      <tag>Boyer-Moore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 4 丑数Ⅱ</title>
    <link href="/2021/07/04/Lintcode-4/"/>
    <url>/2021/07/04/Lintcode-4/</url>
    
    <content type="html"><![CDATA[<p>设计一个算法，找出只含素因子<code>2</code>，<code>3</code>，<code>5</code> 的第 <em>n</em> 小的数。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>设计一个算法，找出只含素因子<code>2</code>，<code>3</code>，<code>5</code> 的第 <em>n</em> 小的数。</p><p>符合条件的数如：<code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12...</code></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：<span class="hljs-number">9</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：<span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当前丑数必定是之前某个丑数的2倍、3倍、或者5倍。</p><p>初始化丑数数组ugly[0]=1，从第一位开始分别乘以2、3、5得到后续丑数。</p><p>注意得到丑数后需要保证数组的大小顺序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: return a  integer as description.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">int</span> ugly[n];<br>        ugly[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">int</span> p2,p3,p5;<br>        p2=p3=p5=<span class="hljs-number">0</span>;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>        &#123;<br>            ugly[i]=min(min(ugly[p2]*<span class="hljs-number">2</span>,ugly[p3]*<span class="hljs-number">3</span>),min(ugly[p2]*<span class="hljs-number">2</span>,ugly[p5]*<span class="hljs-number">5</span>));<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p2]*<span class="hljs-number">2</span>)<br>                ++p2;<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p3]*<span class="hljs-number">3</span>)<br>                ++p3;<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p5]*<span class="hljs-number">5</span>)<br>                ++p5;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ugly[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://blog.csdn.net/htt789/article/details/79992923">https://blog.csdn.net/htt789/article/details/79992923</a></p>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Count</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 394 硬币排成线</title>
    <link href="/2021/07/04/Lintcode-394/"/>
    <url>/2021/07/04/Lintcode-394/</url>
    
    <content type="html"><![CDATA[<p>有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。请判定先手玩家必胜还是必败?</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。</p><p>请判定先手玩家必胜还是必败?</p><p>若必胜，返回true，否则返回false。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 1</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 4</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 先手玩家第一轮拿走一个硬币，此时还剩三个，这时无论后手玩家拿一个还是两个，下一次先手玩家都可以把剩下的硬币拿完。</span><br></code></pre></td></tr></table></figure><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a><strong>挑战</strong></h4><p>O(1) 时间复杂度且O(1) 存储。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>博弈论问题：</p><p>有 n 个硬币排成一条线。两个参赛者 A 和 B 轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。</p><p>当n=1时，A必胜（拿1个）；</p><p>当n=2时，A必胜（拿2个）；</p><p>当n=3时，A必败（A不管拿1个还是2个，B都可以将剩下的棋子一次拿完）；</p><p>当n=4时，A必胜（A拿1个，剩3个，转化为B先手必败）；</p><p>当n=5时，A必胜（A拿2个，同上）；</p><p>当n=6时，A必败（A不管拿1个还是2个，B都可以将棋子拿到只剩3个，转化为A先手必败）；</p><p>……</p><p>当n=9时，A必败（A不管拿1个还是2个，B都可以将棋子拿到只剩6个，转化为A先手必败）；</p><p>综上，</p><p>当n%3 == 0时，A不管拿1个还是2个，B都可以将棋子转化为A先手必败的情况；</p><p>同样，当n%3 != 0时，A都可以将棋子转化为B先手必败的情况。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: A boolean which equals to true if the first player will win</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">firstWillWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>关于博弈论问题的总结，见<a href="https://www.cnblogs.com/Wolfycz/p/8430991.html">浅谈算法——博弈论</a></p>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Lintcode] 3 统计数字</title>
    <link href="/2021/07/04/Lintcode-3/"/>
    <url>/2021/07/04/Lintcode-3/</url>
    
    <content type="html"><![CDATA[<p>计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">k</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：在[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]中，我们发现<span class="hljs-number">1</span>出现了<span class="hljs-number">1</span>次(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：k = <span class="hljs-number">1</span>, n = <span class="hljs-number">12</span><br>输出：<span class="hljs-number">5</span><br>解释：在[<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4,5,6,7</span>,<span class="hljs-number">8,9,10,11</span>,<span class="hljs-number">12</span>]中，我们发现<span class="hljs-number">1</span>出现了<span class="hljs-number">5</span>次(<span class="hljs-number">1,10,11,12</span>)(注意<span class="hljs-number">11</span>中有两个<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>以k = 5为例：</p><p>每10位产生1个数，[0,9]有一个5，[10,19]有一个15，[20,29]有一个25</p><p>每100位产生10个数，[0,99]有10个5，即[50,59]，[100,199]有10个5，即[150,159]</p><p>每1000位产生100个数，[0,999]有100个5，即[500,599]</p><p>以此类推……</p><p>当 n = 2169，k = 1 时：</p><p>个位：9前面有216个10，故有216个1，又因为9&gt;1，所以一共有216+1=217个1</p><p>十位：6前面有21个100，100中有10个1，故有21*10=210个1，又因为6&gt;1，所以包含了10~19的10个1，一共有210+10=220个1</p><p>百位：1前面有2个1000，1000中有100个1，故有2*100=200个1，这里1==1，也就是多了100~169一共70个1，一共有200+70=270个1</p><p>千位：2&gt;1，包含了1000~1999的1000个1</p><p>一共有217+220+270+1000=1707个1</p><p>但当 k = 0 时的情况不同，当 n = 2169，k = 0 时：</p><p>个位：9前面有216个10，故有216个0，又因为9&gt;0，所以一共有216+1=217个0</p><p>十位：6前面有21个100，100中有10个0，故有21*10=210个0，但00到09的情况不存在，故只有210-10=200个0，又因为6&gt;0，所以包含了00到09的10个0，一共有200+10=210个0</p><p>百位：1前面有2个1000，1000中有100个0，故有2*100=200个1，但000到099的情况不存在，故只有200-100=100个0，这里1&gt;0，所以包含了000到099的100个0，一共有100+100=200个0</p><p>千位：2&gt;0，但0000到0999的情况不存在</p><p>一共有217+210+200=627个0</p><p>因此，当计算从右往左数第 i位包含 k 的个数时：</p><p>若第 i 位大于k，则结果为**第 i 位左边所有数字乘以10<sup>i-1</sup>次方 **+ <strong>10<sup>i-1</sup>次方</strong></p><p>若第 i 位小于k，则结果为<strong>第 i 位左边的所有数字乘以10<sup>i-1</sup>次方</strong></p><p>若第 i 位等于k，则结果为**第 i 位左边所有数字乘以10<sup>i-1</sup>次方 **+ <strong>右边的所有数字</strong>+<strong>1</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param k: An integer</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: An integer denote the count of digit k in 1..n</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">digitCounts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">int</span> bit=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前位的权重</span><br>        <span class="hljs-keyword">int</span> bitnum=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前位的具体数字</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//k出现的总次数</span><br>        <span class="hljs-keyword">int</span> val=n;<span class="hljs-comment">//赋值val用于计算每位</span><br>        <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//处理k=0时候的情况，t为要减去的情况之和</span><br>    <br>        <span class="hljs-keyword">if</span>(n==k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(val!=<span class="hljs-number">0</span>)<br>        &#123;<br>            bitnum=val-(val/<span class="hljs-number">10</span>)*<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(bitnum&lt;k)<br>                sum+=(val/<span class="hljs-number">10</span>)*bit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bitnum==k)<br>                sum+=(val/<span class="hljs-number">10</span>)*bit+n-val*bit+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                sum+=(val/<span class="hljs-number">10</span>)*bit+bit;<br>            t+=bit;<br>            bit*=<span class="hljs-number">10</span>;<br>            val/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            sum-=(t<span class="hljs-number">-1</span>);<span class="hljs-comment">//减1是去掉bit为1时的情况，即0的情况存在</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol><li><a href="https://blog.csdn.net/Flag_died/article/details/104062613">https://blog.csdn.net/Flag_died/article/details/104062613</a></li><li><a href="https://blog.csdn.net/weixin_42316707/article/details/86510114">https://blog.csdn.net/weixin_42316707/article/details/86510114</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Count</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 1089 有效的括号字符串</title>
    <link href="/2021/07/04/Lintcode-1089/"/>
    <url>/2021/07/04/Lintcode-1089/</url>
    
    <content type="html"><![CDATA[<p>给定一个只包含三种类型字符的字符串：’(‘、’)’ 和 ‘*’，编写一个函数来检查该字符串是否有效。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个只包含三种类型字符的字符串：’(‘、’)’ 和 ‘*’，编写一个函数来检查该字符串是否有效。我们通过以下规则定义字符串的有效性：</p><ol><li>任何左括号 ‘(‘ 必须有一个相应的右括号 ‘)’</li><li>任何右括号 ‘)’ 必须有一个相应的左括号 ‘(‘</li><li>左括号 ‘(‘ 必须在相应的右括号 ‘)’ 之前</li><li>‘*’ 可以被视为单个右括号 ‘ )’ 或单个左括号 ‘(‘ 或空字符串</li><li>空字符串也有效。</li></ol><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>样例1：输入：”()”           输出：true<br>样例2：输入：”(*)”         输出：true          解释：’*‘看做是空<br>样例3：输入：”(*))”        输出：true          解释: ‘*’ 当作’(‘</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历字符数组，遇到左括号，左括号索引放入左括号栈，遇到*号，索引放入star栈。当遇到右括号的时候，这就先优先从左括号出栈，如果左括号栈空了，再从star栈出栈。</p><p>需要注意，*(这个情况，他不是有效括号。基于这个问题，栈就不能单纯的存字符括号和*号了，必须存放索引，当遍历完后，需要比较索引。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> lintcode;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>Stack&lt;Integer&gt; leftParenthesis=<span class="hljs-keyword">new</span> Stack&lt;&gt; ();<span class="hljs-comment">//左括号</span><br>Stack&lt;Integer&gt; starParenthesis=<span class="hljs-keyword">new</span> Stack&lt;&gt; ();<span class="hljs-comment">//星号</span><br><span class="hljs-keyword">char</span> []arr=s.toCharArray();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br><span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>leftParenthesis.push(i);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>starParenthesis.push(i);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span>(!leftParenthesis.isEmpty())<br>leftParenthesis.pop();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!starParenthesis.isEmpty())<br>starParenthesis.pop();<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//遍历完字符数组后，需要判断左括号栈，和*栈了。针对*（这中情况,左括号在*号的右边</span><br><span class="hljs-keyword">while</span>(!leftParenthesis.isEmpty()&amp;&amp;!starParenthesis.isEmpty()) &#123;<br><span class="hljs-keyword">if</span>(leftParenthesis.peek()&gt;starParenthesis.peek())<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">else</span> &#123;<br>leftParenthesis.pop();<br>starParenthesis.pop();<br>&#125;<br>&#125;<br><span class="hljs-comment">//最后只需要判断左括号是否有剩余。最后如果剩下的都是***,那都是有效括号空字符</span><br><span class="hljs-keyword">return</span> leftParenthesis.isEmpty();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>Scanner in=<span class="hljs-keyword">new</span> Scanner(System.in);<br>String s=in.nextLine();<br><span class="hljs-keyword">boolean</span> k=checkValidString(s);<br>System.out.print(k);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="Java-Stack类"><a href="#Java-Stack类" class="headerlink" title="Java Stack类"></a>Java Stack类</h5><p>栈是Vector的一个子类，它实现了一个标准的后进先出的栈；</p><p>堆栈只定义了默认构造函数，用来创建一个空栈；</p><p>堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-comment">//测试堆栈是否为空。</span></span><br><span class="hljs-function">Object <span class="hljs-title">peek</span><span class="hljs-params">()</span><span class="hljs-comment">//查看堆栈顶部的对象，但不从堆栈中移除它。</span></span><br><span class="hljs-function">Object <span class="hljs-title">pop</span><span class="hljs-params">()</span><span class="hljs-comment">//移除堆栈顶部的对象，并作为此函数的值返回该对象。</span></span><br><span class="hljs-function">Object <span class="hljs-title">push</span><span class="hljs-params">(Object element)</span><span class="hljs-comment">//把项压入堆栈顶部。</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Object element)</span><span class="hljs-comment">//返回对象在堆栈中的位置，以 1 为基数。</span></span><br></code></pre></td></tr></table></figure><h5 id="Java-输入输出流"><a href="#Java-输入输出流" class="headerlink" title="Java 输入输出流"></a>Java 输入输出流</h5><p>Java的输出函数很简单，直接调用System类的out对象的print函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(a);<span class="hljs-comment">//输出变量a的值</span><br>System.out.print(<span class="hljs-string">&quot;214214&quot;</span>);<span class="hljs-comment">//输出字符串</span><br>System.out.print(<span class="hljs-string">&quot;123&quot;</span>+a);<span class="hljs-comment">//混合输出字符串和变量值</span><br></code></pre></td></tr></table></figure><p>Java的输入函数还是Scanner类最好用，它既可以读字符，也可以读字符串和整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> </span>&#123; <br>         Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的姓名：&quot;</span>); <br>         String name = sc.nextLine(); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的年龄：&quot;</span>); <br>         <span class="hljs-keyword">int</span> age = sc.nextInt(); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的工资：&quot;</span>); <br>         <span class="hljs-keyword">float</span> salary = sc.nextFloat(); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Java</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Notes] 常用命令</title>
    <link href="/2021/07/04/note-command/"/>
    <url>/2021/07/04/note-command/</url>
    
    <content type="html"><![CDATA[<p>常用命令 of Linux, Redis, Vim, Git, SSH and MarkDown</p><span id="more"></span><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>查看PCI-E插槽使用情况：dmidecode | grep -1 PCI</li><li>查看显卡信息：lspci | grep -i vga</li></ul><ul><li>复制粘贴文件：　　cp  [选项]  源文件或目录  目标文件或目录</li><li>剪切粘贴文件：　　mv  [选项]  源文件或目录  目标文件或目录</li></ul><ul><li>创建文件夹： mkdir</li><li>删除文件：rm -rf 文件名   <ul><li>//-r 就是向下递归，不管有多少级目录，一并删除</li><li>//-f 就是直接强行删除，不作任何提示的意思）</li></ul></li><li>查看文件系统： df</li></ul><ul><li><p>压缩：tar -zcvf archive_name.tar.gz filename</p></li><li><p>解压缩：</p><ul><li>tar -zxvf archive_name.tar.gz (-C new_dir)</li><li>unzip zipped_file.zip (-d unzipped_directory)</li></ul></li></ul><ul><li><p>复制文件：</p><ul><li>cp dir1/a.doc dir2  表示将dir1下的a.doc文件复制到dir2目录下</li><li>cp -r dir1 dir2     表示将dir1及其dir1下所包含的文件复制到dir2下</li><li>cp -r dir1/. dir2   表示将dir1下的文件复制到dir2,不包括dir1目录</li></ul></li></ul><ul><li>修改kernel配置参数：<ul><li>目录：cd proc/sys/kernel</li><li>修改：echo value &gt;修改项（不能使用vim，vim需要copy一份修改后在覆盖，权限不够）</li></ul></li></ul><ul><li>查看各用户占用空间：sudo du -sh /home/*</li></ul><hr><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>获取redis中所有的key：  redis 127.0.0.1:6379&gt; KEYS *</li><li>删除数据库所有数据：FLUSHALL</li><li>redis-server  直接启动</li><li>redis-server  配置路径  如redis-server  /etc/redis.conf<br>这时候要后台启动的话就需要配置redis.conf中的daemonize no改为yes</li><li>停止   redis-cli (-a 密码) -h 127.0.0.1 -p 6379 shutdown</li><li>确认是否启动，使用  ps -ef|grep redis</li><li>查看结点状态：INFO</li><li>查看集群状态：CLUSTER INFO</li><li>查看集群的槽：cluster slots</li><li>redis集群，添加新节点：CLUSTER MEET 127.0.0.1 7002</li><li>Redis清空数据库：flushall</li></ul><hr><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul><li><p>有三个快捷键可以进入编辑模式，a i o</p></li><li><p>保存并退出，输入:wq</p></li><li><p>查找字符串，输入/或者？加需要查找的字符串，查看下一个，小写n，跳转到上一个，大写N</p></li><li><p>[Ctrl] + [f]    屏幕『向下』移动一页，相当于 [Page Down]按键<br>[Ctrl] + [b]    屏幕『向上』移动一页，相当于 [Page Up] 按键</p></li><li><p>:num   直接跳到第num行。</p></li><li><p>多行注释：</p><ol><li><p>进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来</p></li><li><p>按大写字母I，再插入注释符，例如//</p></li><li><p>按esc键就会全部注释了</p></li></ol></li><li><p>取消多行注释：</p><ol><li>进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列</li><li>按字母j，或者k选中注释符号</li><li>按d键就可全部取消注释</li></ol></li><li><p>定位到文件尾：G</p></li></ul><hr><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>初始化：git init</li><li>添加到github远程仓库：git remote add origin 仓库链接</li><li>下载代码：git clone URL</li><li>查看分支：git branch （-a 查看所有分支）</li><li>切换分支：git checkout 分支名</li><li>如果我们修改了本地的某个文件但是没有提交，这时我们用 $ git status可以看到提示</li><li>批量提交修改：git add –all</li><li>拉取：git pull</li><li>上传：git push origin master</li></ul><hr><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>在终端连接ssh的断开关闭退出的方法</p><ol><li>输入logout    比较正式的退出方式</li><li>输入exit        等同于方法1</li><li>Ctrl + D        等同于方法1，方便快捷</li></ol><hr><h3 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h3><ul><li>上下标：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">H&lt;sub&gt;<span class="hljs-number">2</span>&lt;/sub&gt;O  CO&lt;sub&gt;<span class="hljs-number">2</span>&lt;/sub&gt;<br>爆米&lt;sup&gt;TM&lt;/sup&gt;<br></code></pre></td></tr></table></figure><p>显示效果为：H<sub>2</sub>O    CO<sub>2</sub>    爆米<sup>TM</sup></p><ul><li>显示空行：&amp;nbsp;</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Command</tag>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
      <tag>Redis</tag>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Tutorial] Pycharm+PyQt5</title>
    <link href="/2021/07/04/Pycharm-PyQt5/"/>
    <url>/2021/07/04/Pycharm-PyQt5/</url>
    
    <content type="html"><![CDATA[<h4 id="Pycharm-amp-PyQt5-环境搭建记录"><a href="#Pycharm-amp-PyQt5-环境搭建记录" class="headerlink" title="Pycharm &amp; PyQt5 环境搭建记录"></a>Pycharm &amp; PyQt5 环境搭建记录</h4><span id="more"></span><h5 id="Step1：环境搭建"><a href="#Step1：环境搭建" class="headerlink" title="Step1：环境搭建"></a>Step1：环境搭建</h5><ul><li><p>过程参考：</p><p><a href="https://www.jb51.net/article/162137.htm">https://www.jb51.net/article/162137.htm</a></p><p><a href="https://blog.csdn.net/px41834/article/details/79383985">https://blog.csdn.net/px41834/article/details/79383985</a></p></li><li><p>主要问题：</p><ol><li><p>designer.exe路径问题：</p><p>designer的路径可能并不是..\venv\Lib\site-packages\pyqt5-tools\designer.exe，建议使用Everything直接搜索designer.exe，有可能位于..\venv\Lib\site-packages\qt5_applications\Qt\bin</p></li><li><p>无法启动qtdesigner：</p><p><img src="/img/article/Tutorial/20200616112822349.png"></p><p>添加环境变量，参考<a href="http://www.xiaoheidiannao.com/15127.html">http://www.xiaoheidiannao.com/15127.html</a></p><p>变量名：QT_QPA_PLATFORM_PLUGIN_PATH</p><p>变量值：与designer同级的plugins文件夹路径</p></li></ol></li></ul><h5 id="Step2：designer入门"><a href="#Step2：designer入门" class="headerlink" title="Step2：designer入门"></a>Step2：designer入门</h5><ul><li><p>参考：</p><p><a href="https://blog.csdn.net/azuremouse/article/details/90338961">https://blog.csdn.net/azuremouse/article/details/90338961</a></p><p><a href="https://blog.csdn.net/yl_best/article/details/83825223">https://blog.csdn.net/yl_best/article/details/83825223</a></p></li></ul><h5 id="Step3：Table-View入门"><a href="#Step3：Table-View入门" class="headerlink" title="Step3：Table View入门"></a>Step3：Table View入门</h5><ul><li>参考：<a href="https://blog.csdn.net/jia666666/article/details/81624259">https://blog.csdn.net/jia666666/article/details/81624259</a></li></ul><h5 id="Step4：生成可执行文件"><a href="#Step4：生成可执行文件" class="headerlink" title="Step4：生成可执行文件"></a>Step4：生成可执行文件</h5><ul><li>参考：<a href="https://blog.csdn.net/qq_32939413/article/details/86564611">https://blog.csdn.net/qq_32939413/article/details/86564611</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Qt</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Redis] Redis持久化机制的源码分析</title>
    <link href="/2021/07/04/Redis-code/"/>
    <url>/2021/07/04/Redis-code/</url>
    
    <content type="html"><![CDATA[<p>文章基于Redis-4.0版本，介绍AOF持久化策略的具体实现过程，包括AOF持久化的触发，文件追加、写入、同步的代码实现，启动阶段的数据还原实现，AOF重写的触发与实现等。</p><span id="more"></span><hr><h3 id="1-AOF持久化"><a href="#1-AOF持久化" class="headerlink" title="1 AOF持久化"></a>1 AOF持久化</h3><h4 id="1-1-AOF触发"><a href="#1-1-AOF触发" class="headerlink" title="1.1 AOF触发"></a>1.1 AOF触发</h4><p>Redis执行命令时都会先建立一个客户端，然后由客户端去和服务器连接， redis的命令执行中有一个核心部分，就是call()方法，call函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* src/server.c/call() */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(client *c, <span class="hljs-keyword">int</span> flags)</span></span><br></code></pre></td></tr></table></figure><p>其中client代表客户端，flags是一个特殊标识，当flags为CLIENT_FORCE_AOF时，标志着强制服务器将当前执行的命令写入到AOF文件当中。除此之外，在call函数执行过程中还维护着一个变量dirty用来标识当前执行的命令操作是否改变服务器数据，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">dirty = server.dirty;  <br>c-&gt;cmd-&gt;proc(c);  <span class="hljs-comment">//实际的命令执行函数</span><br>dirty = server.dirty-dirty;  <br><span class="hljs-keyword">if</span> (dirty &lt; <span class="hljs-number">0</span>) dirty = <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure><p>通过以上两个判断条件，就可以设置命令传播的标识，进而调用传播方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dirty)   propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);  <br><span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)   propagate_flags |= PROPAGATE_AOF;  <br> <br><span class="hljs-comment">//Call propagate only if at least one of AOF/REPL propagation is needed</span><br><span class="hljs-keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))  <br>    propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);  <br></code></pre></td></tr></table></figure><h4 id="1-2-文件追加、写入、同步"><a href="#1-2-文件追加、写入、同步" class="headerlink" title="1.2 文件追加、写入、同步"></a>1.2 文件追加、写入、同步</h4><p>propagate()函数的作用是将命令传播给AOF以及slave中（slave是Redis集群部分的内容），propagate()将命令传播到AOF中是通过调用feedAppendOnlyFile()函数实现的，在调用该函数之前，首先需要检查AOF机制是否已开启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* src/server.c/propagate() */</span>  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">propagate</span><span class="hljs-params">(struct redisCommand *cmd, <span class="hljs-keyword">int</span> dbid, robj **argv, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;  <br> <span class="hljs-keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)  <br>     feedAppendOnlyFile(cmd,dbid,argv,argc);  <br>&#125; <br></code></pre></td></tr></table></figure><p>feedAppendOnlyFile()位于src/aof.c中，该函数将命令追加至aof_buf中，如果正在执行AOF重写，还需要将其追加到重写缓冲区中，具体实现过程包括以下四个步骤：</p><ol><li>使用 SELECT 命令，显式设置数据库，确保之后的命令被设置到正确的数据库；</li><li>将命令和命令参数还原为协议格式；</li><li>将命令追加到aof_buf中（使用函数sdscatlen()实现，该函数为Redis自定义的，针对sds结构实现的追加函数，位于src/sds.c中）；</li><li>如果BGREWRITEAOF正在进行，还需要将命令追加到重写缓存中（使用函数aofRewriteBufferAppend()实现，位于src/aof.c中）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Append to the AOF buffer. This will be flushed on disk just before </span><br><span class="hljs-comment"> * of re-entering the event loop, so before the client will get a </span><br><span class="hljs-comment"> * positive reply about the operation performed. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_state == AOF_ON)  <br>server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));  <br><span class="hljs-comment">/* If a background append only file rewriting is in progress we want to </span><br><span class="hljs-comment"> * accumulate the differences between the child DB and the current one </span><br><span class="hljs-comment"> * in a buffer, so that when the child process will do its work we </span><br><span class="hljs-comment"> * can append the differences to the new append only file. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>)  <br>aofRewriteBufferAppend((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)buf,sdslen(buf));<br></code></pre></td></tr></table></figure><p>AOF文件的写入和同步采用的是src/aof.c/flushAppendOnlyFile函数。该函数在src/server.c/beforeSleep中会被调用，而beforeSleep函数是在处理client事件之前执行的（事件循环函数aeMain先执行beforesleep，然后执行aeProcessEvents），因此，server.aof_buf中的值会在向client发送响应之前刷新到磁盘上。</p><p>flushAppendOnlyFile(int force)函数的具体实现过程中，根据不同的同步策略以及后台是否有正在进行fsync操作，共分为以下几种情况：</p><ol><li>判断是否写入，同步策略为everysecond（server.aof_fsync == AOF_FSYNC_EVERYSEC），且没有要求强制写入（!force），且有fsync正在后台执行：<ul><li>之前没有推迟过write操作，则记录下时间，直接返回（如果此时强制执行write的话，服务器主线程将阻塞在write上面）；</li><li>之前推迟过write操作，但推迟时间&lt;2秒，直接返回；</li><li>推迟时间&gt;=2秒，不返回，继续执行。</li></ul></li><li>执行写入操作，调用aofWrite函数</li><li>判断是否同步：<ul><li>同步策略为always（server.aof_fsync == AOF_FSYNC_ALWAYS），执行同步操作（调用aof_fsync函数，在Linux系统，该函数使用fdatasync实现，在其他系统中，使用fsync实现）。</li><li>同步策略为everysecond，且距离上次写操作已超过1秒，且没有fsync在后台执行，则后台执行同步操作（调用aof_background_fsync函数）。</li></ul></li></ol><hr><h3 id="2-数据还原"><a href="#2-数据还原" class="headerlink" title="2 数据还原"></a>2 数据还原</h3><p>Redis启动之后，在src/server.c/main()函数中调用loadDataFromDisk()，当AOF为开启状态时，该函数会继续调用src/aof.c/loadAppendOnlyFile()，在该函数中会通过创建伪客户端的方式，遍历执行AOF文件的命令，还原数据库状态。</p><hr><h3 id="3-AOF重写"><a href="#3-AOF重写" class="headerlink" title="3 AOF重写"></a>3 AOF重写</h3><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由server.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等；</li><li>清理数据库中的过期键值对；</li><li>关闭和清理连接失效的客户端；</li><li>触发BGSAVE或者AOF重写，并处理之后由BGSAVE和AOF重写引发的子进程停止。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每秒调用server.hz次，直到服务器关闭为止。</p><h4 id="3-1-BGSAVE和BGREWRITEAOF的触发"><a href="#3-1-BGSAVE和BGREWRITEAOF的触发" class="headerlink" title="3.1 BGSAVE和BGREWRITEAOF的触发"></a>3.1 BGSAVE和BGREWRITEAOF的触发</h4><p>在serverCron()函数中与Redis持久化相关的检查以及处理流程如下图所示，具体实现包括：</p><p><img src="/img/article/Redis/image-20200607224305949.png" alt="serverCron中相关操作流程"></p><ul><li>如果BGSAVE和BGREWRITEAOF都没有在执行，但是有一个BGREWRITEAOF在等待（server.aof_rewrite_scheduled），那么执行BGREWRITEAOF（调用函数src/aof.c/rewriteAppendOnlyFileBackground）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Start a scheduled AOF rewrite if this was requested by the user while </span><br><span class="hljs-comment"> * a BGSAVE was in progress. */</span>  <br><span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;  <br>server.aof_rewrite_scheduled) &#123;  <br>rewriteAppendOnlyFileBackground();  <br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>如果BGSAVE和BGREWRITEAOF都没有在执行，而且也没有BGREWRITEAOF在等待，那么检查是否需要执行它们<ul><li>BGSAVE：检查m秒内是否发生了超过n次的变化（对应于配置文件中的save m n），BGSAVE操作由函数src/rdb.c/rdbSaveBackground实现</li><li>BGREWRITEAOF：<ul><li>当前AOF文件大小大于执行 BGREWRITEAOF 所需的最小大小，即server.aof_rewrite_min_size</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-perc）</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Trigger an AOF rewrite if needed */</span>  <br><span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;  <br>    server.aof_rewrite_perc &amp;&amp;  <br>    server.aof_current_size &gt; server.aof_rewrite_min_size)  &#123;  <br>    <span class="hljs-comment">// 上一次完成 AOF 写入之后，AOF 文件的大小  </span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = server.aof_rewrite_base_size ?  <br>                 server.aof_rewrite_base_size : <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// AOF 文件当前的体积相对于 base 的体积的百分比  </span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> growth = (server.aof_current_size*<span class="hljs-number">100</span>/base) - <span class="hljs-number">100</span>;  <br><span class="hljs-comment">// 如果增长体积的百分比超过了 growth ，那么执行 BGREWRITEAOF  </span><br><span class="hljs-keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123; <br>    rewriteAppendOnlyFileBackground();  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>如果存在BGSAVE或者BGREWRITEAOF在执行，则检查其是否已经执行完毕，并处理因此而引发的子进程停止</li><li>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写人的数据，那么serverCron会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync </span><br><span class="hljs-comment"> * completed. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_flush_postponed_start)   <br> flushAppendOnlyFile(<span class="hljs-number">0</span>);  <br></code></pre></td></tr></table></figure><p>在serverCron函数中会通过检查BGREWRITEAOF的两个自动触发条件来执行AOF重写，但除此之外，用户还可以通过在客户端输入bgwriteaof命令来手动触发AOF重写。与其他命令的处理流程相同，bgwriteaof命令对应的命令处理函数为aof.c/bgrewriteaofCommand()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bgrewriteaofCommand</span><span class="hljs-params">(client *c)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>) &#123;  <br>        addReplyError(c,<span class="hljs-string">&quot;Background AOF rewriting already in progress&quot;</span>);  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (server.rdb_child_pid != <span class="hljs-number">-1</span>) &#123;  <br>    server.aof_rewrite_scheduled = <span class="hljs-number">1</span>;  <br>    addReplyStatus(c,<span class="hljs-string">&quot;Background append only file rewriting scheduled&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rewriteAppendOnlyFileBackground() == C_OK) &#123;  <br>    addReplyStatus(c,<span class="hljs-string">&quot;Background append only file rewriting started&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>    addReply(c,shared.err);  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>在该函数中，AOF重写也是通过调用rewriteAppendOnlyFileBackground函数来实现的。但当有BGSAVE在执行时（server.rdb_child_pid != -1），BGREWRITEAOF会等待（server.aof_rewrite_scheduled = 1），如前文所述，等待的BGREWRITEAOF会在serverCron函数中被执行。</p><h4 id="3-2-AOF重写的实现"><a href="#3-2-AOF重写的实现" class="headerlink" title="3.2 AOF重写的实现"></a>3.2 AOF重写的实现</h4><p>AOF重写是依靠rewriteAppendOnlyFileBackground函数实现的，该函数的处理过程包括：</p><ol><li>使用fork创建一个子进程；</li><li>子进程调用aof.c/rewriteAppendOnlyFile函数在一个临时文件里写入能够反映当前db状态的数据和命令，此时父进程会把这段时间内执行的能够改变当前db数据的命令放到重写缓冲区中；</li><li>当子进程退出时，父进程收到信号，将上面的重写缓冲区中的数据flush到临时文件中，然后将临时文件rename成新的aof文件。</li></ol><p>子进程调用rewriteAppendOnlyFile函数后，在该函数中会继续调用实际的重写函数aof.c/rewriteAppendOnlyFileRio，该函数遍历db中的每条数据，取出键，取出值，然后根据值的类型选择适当的命令来进行保存，然后写入并同步AOF临时文件中。</p><p>在serverCron函数中，会周期性的检查BGREWRITEAOF子进程是否已退出，当父进程收到退出信号后，会调用aof.c/backgroundRewriteDoneHandler函数完成后续处理，包括：</p><ol><li>调用aof.c/aofRewriteBufferWrite函数，将累计的AOF重写缓冲区的内容追加到AOF临时文件中；</li><li>将AOF 临时文件rename，替换现有的AOF文件。</li></ol><p>参考内容：《Redis设计与实现》，黄健宏著</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持久化</tag>
      
      <tag>AOF</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Redis] Redis的数据持久化机制</title>
    <link href="/2021/07/04/Redis-AOF-RDB/"/>
    <url>/2021/07/04/Redis-AOF-RDB/</url>
    
    <content type="html"><![CDATA[<p>Redis作为一种高性能的内存数据库，将全部数据储存在内存当中，因此一旦发生服务器宕机或系统崩溃，存储的数据就会全部丢失。为了解决这一问题，Redis提供RDB和AOF两种持久化机制，将数据同步到磁盘中。当系统或服务器重启时，利用持久化文件即可恢复数据，有效的避免了数据丢失问题。</p><span id="more"></span><hr><h3 id="1-RDB持久化"><a href="#1-RDB持久化" class="headerlink" title="1 RDB持久化"></a>1 RDB持久化</h3><p>RDB持久化方式是通过快照（snapshotting）完成的，当符合一定条件时，redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当redis重启时，redis会读取RDB持久化生成的二进制文件进行数据恢复。</p><h4 id="1-1-RDB持久化的触发条件"><a href="#1-1-RDB持久化的触发条件" class="headerlink" title="1.1 RDB持久化的触发条件"></a>1.1 RDB持久化的触发条件</h4><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><p>save命令触发</p><p>客户端执行save命令，该命令强制redis执行快照，这时候redis处于阻塞状态，不会响应任何其他客户端发来的请求，直到RDB快照文件执行完毕，所以请慎用。</p></li><li><p>bgsave命令触发</p><p>bgsave，即后台保存，当执行bgsave命令时，redis会fork出一个子进程来执行快照生成操作，需要注意的redis是在fork子进程这个简短的时间redis是阻塞的，当子进程创建完成以后redis继续响应客户端请求。执行过程如下图所示：</p></li></ul><p><img src="/img/article/Redis/RDB%E6%8C%81%E4%B9%85%E5%8C%96bgsave%E8%BF%87%E7%A8%8B.jpg" alt="RDB持久化bgsave过程"></p><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p><p>自动触发实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。</p><p>除了save m n以外，还有一些其他情况会触发bgsave， 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点。执行shutdown命令时，也会自动执行rdb持久化。</p><h4 id="1-2-RDB持久化的优缺点"><a href="#1-2-RDB持久化的优缺点" class="headerlink" title="1.2 RDB持久化的优缺点"></a>1.2 RDB持久化的优缺点</h4><ul><li>优点：<ol><li>RDB是一个非常紧凑的文件，体积小，易于传输，适合灾难恢复。</li><li>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O操作。</li><li>RDB在恢复大数据集时的速度比AOF的恢复速度要快。</li></ol></li><li>缺点：<ol><li>RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。</li><li>RDB需要fork子进程将内容持久化在磁盘上。如果数据集很大，fork可能很耗时，并且如果数据集很大且CPU性能不佳，则可能导致Redis停止服务几毫秒甚至一秒钟。AOF机制也需要fork，但可以调整重写日志的频率。</li></ol></li></ul><hr><h3 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2 AOF持久化"></a>2 AOF持久化</h3><p>除了RDB持久化功能外，Redis还提供了AOF持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><h4 id="2-1-AOF持久化的实现"><a href="#2-1-AOF持久化的实现" class="headerlink" title="2.1 AOF持久化的实现"></a>2.1 AOF持久化的实现</h4><p>AOF 持久化功能的实现可以分为命令追加，文件写入，文件同步三个步骤。</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。其中aof_buf的定义位于redisServer结构体中。</p><h5 id="AOF文件的同步和写入"><a href="#AOF文件的同步和写入" class="headerlink" title="AOF文件的同步和写入"></a>AOF文件的同步和写入</h5><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里，所以在服务器每次结束一个事件循环之前，他都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和同步到AOF文件中。</p><p>针对flushAppendOnlyFile函数的行为，redis提供了三种同步策略，由配置参数appendfsync来决定，各个不同值产生的行为如下所示：</p><ul><li>everysec：将aof_buf 缓冲区中的所有内容写入到AOF 文件，如果上次同步AOF 文件的时间距离现在超过一秒钟，那么再次对AOF 文件进行同步，并且这个同步操作是由一个专门负责执行的。</li><li>always：将aof_buf 缓冲区的所有内容写入并同步到AOF 文件中。</li><li>no：将aof_buf 缓冲区的所有内容写入到AOF 文件中，但并不对AOF 文件进行同步，合适同步由操作系统决定。</li></ul><p>从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失1秒的命令数据。这是折中的方案，兼顾性能和数据安全，也是redis的默认配置。</p><p>always模式在每次写操作后都调用fsync方法强制内核将数据写入到aof文件。这种情况下虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。</p><p>no模式下的同步交给操作系统write函数去执行，这种情况下，AOF文件写入速度是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</p><h4 id="2-2-AOF文件的载入与数据还原"><a href="#2-2-AOF文件的载入与数据还原" class="headerlink" title="2.2 AOF文件的载入与数据还原"></a>2.2 AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。Redis读取AOF文件并还原数据库的详细步骤如下图所示。</p><p><img src="/img/article/Redis/AOF%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E8%BF%87%E7%A8%8B.jpg" alt="AOF文件载入过程"></p><p>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和网络连接的客户端执行命令的效果完全一样。</p><h4 id="2-3-AOF重写"><a href="#2-3-AOF重写" class="headerlink" title="2.3 AOF重写"></a>2.3 AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，同时使用AOF文件来进行数据还原所需的时间也越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><p>假设服务器对某一个key执行了多个写命令，那么服务器为了保存该key的当前状态，必须将这些写命令全部写入AOF文件中。如果服务器想要用尽量少的命令来记录该key的状态，最简单高效的办法不是去读取和分析现有AOF文件的内容，而是直接从数据库中读取该key对应的value值，然后用一条写命令命令来代替原有的多个写命令即可，这就是AOF重写功能的实现原理。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。在Redis4.0版本中，AOF_REWRITE_ITEMS_PER_CMD常量的值为64。</p><h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用AOF重写函数的话，那么在重写期间，服务期将无法处理客户端发来的命令请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>但子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区（aof_rewrite_buf），这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF文件触发条件可分为手动触发和自动触发：</p><ul><li>手动触发：客户端执行bgrewriteaof命令。</li><li>自动触发：自动触发通过以下两个配置协作生效：<ol><li>uto-aof-rewrite-min-size: AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64MB。</li><li>auto-aof-rewrite-percentage：当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。</li></ol></li></ul><p>每次当serverCron（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：</p><ul><li>没有BGSAVE命令（RDB持久化）/AOF持久化在执行；</li><li>没有BGREWRITEAOF在进行；</li><li>当前AOF文件大小要大于server.aof_rewrite_min_size的值；</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-perc）<br>整个AOF后台重写过程如下所示：</li></ul><p><img src="/img/article/Redis/AOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.jpg" alt="AOF后台重写过程"></p><ol><li>开始bgrewriteaof</li><li>主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。</li><li>主进程fork完子进程继续接受客户端请求，此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区aof_rewrite_buf。</li><li>子进程通过内存快照，按照命令重写策略写入到新的AOF文件。<ul><li>子进程写完新的AOF文件后，向主进程发信号。</li><li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li></ul></li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><h4 id="2-4-AOF持久化的优缺点"><a href="#2-4-AOF持久化的优缺点" class="headerlink" title="2.4 AOF持久化的优缺点"></a>2.4 AOF持久化的优缺点</h4><ul><li>优点：<ol><li> 更高的数据安全性，同时有不同的同步策略</li><li> AOF包含一个格式清晰、易于理解的日志文件记录所有的修改操作。</li><li> AOF机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。同时Redis还提供redis-check-aof工具来解决数据一致性的问题。</li></ol></li><li>缺点：<ol><li> 数据文件体积较大，即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。</li><li> 相对RDB方式，AOF模式的恢复速度慢于RDB。</li><li> 由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但仍在一个可以接受的范围内。</li></ol></li></ul><hr><h3 id="3-RDB-AOF混合持久化"><a href="#3-RDB-AOF混合持久化" class="headerlink" title="3 RDB-AOF混合持久化"></a>3 RDB-AOF混合持久化</h3><p>从redis4.0开始，添加了新的混合持久化方式，这里介绍的混合持久化就是同时结合RDB持久化以及AOF持久化混合写入AOF文件。这样做的好处是可以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据，缺点是AOF里面的RDB部分就是压缩格式不再是AOF格式，可读性差。</p><p>混合持久化同样也是通过bgrewriteAOF完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入AOF文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说，新的AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。</p><p>当我们开启了混合持久化时，启动redis依然优先加载AOF文件，AOF文件加载可能有两种情况如下：</p><ul><li>AOF文件开头是RDB的格式，先加载RDB内容再加载剩余的AOF。</li><li>AOF文件开头不是RDB的格式，直接以AOF格式加载整个文件。</li></ul><p>参考内容：<br>[1]《redis系列–redis4.0深入持久化》，<a href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a><br>[2]《Redis设计与实现》，黄健宏著</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持久化</tag>
      
      <tag>RDB</tag>
      
      <tag>AOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Paper] Pangolin: A Fault-Tolerant Persistent Memory Programming Library</title>
    <link href="/2021/07/03/Pangolin/"/>
    <url>/2021/07/03/Pangolin/</url>
    
    <content type="html"><![CDATA[<p>论文发表于2019年USENIX Annual Technical Conference(ATC)中，提出了一种能实现fault tolerance的，基于DAX-map的NVMM编程库——Pangolin。论文出自加州大学圣地亚哥分校的Non-Volatile Systems Laboratory(NVSL)。该实验室专注于新型内存技术的研究，近年来在ATC、FAST、ASPLOS等A类会议发表多篇高水平论文，包括基于非易失性内存的测试框架、文件系统、编程库等多个方向。</p><p>非易失性内存(NVMM)的一个重要特征就是支持DAX模式，在该模式下，实现崩溃一致性(Crash consistency)和容错(Fault tolerance)都十分必要，近年来已经有诸多实验团队针对Crash consistency提出解决方法，但对于Fault tolerance的研究还比较稀少。在这样的背景下，论文提出了一种能实现fault tolerance的，基于DAX-map的NVMM编程库——Pangolin，用于应用程序在NVMM中构建复杂的数据结构。Pangolin结合了校验和(checksum)、奇偶校验(parity)和微缓冲(micro-buffer)三种技术，能够同时避免media error和software bug带来的损害，并支持自动检测和在线恢复。与现阶段支持fault tolerance的NVMM编程库相比，Pangolin使用了的很小的存储开销，达到了类似的性能。</p><p>现阶段的NVM编程库libpmemobj通过副本(replication)的方法来实现fault tolerance，但这样会带来100%的空间开销，为了减少存储开销，Pangolin提出了下图所示的数据保护模式：</p><p><img src="/img/article/Paper/1.png"></p><p>对于一个NVMM pool，其中pool和zone的元数据PM和ZM，以及Log区域仍然采用replication的方式进行容错，因为这一部分所占的存储空间很小（对于1GB的pool，只占用0.1%的存储空间）。对于chunk区域，在逻辑上将其组织为二维数组的形式，最后一行作为parity data进行奇偶检验，chunk的元数据CM和object data都通过parity来进行数据容错。同时，Pangolin还在每个object header中开辟了32 bit的区域存放checksum，进行object data的错误检测。</p><p>为了降低更新checksum和parity所带来的的一致性挑战，Pangolin引入了micro-buffer。当需要修改一个PMEM中的object时，需要在micro-buffer中做一个object的shadow copy，对object的修改将在DRAM中进行，修改完成后重新计算checksum，将checksum和修改操作记录到Log中，随后进行parity的更新操作，当以上步骤都完成以后，将修改后的object写回PMEM中。一次完整的流程如下图所示：</p><p><img src="/img/article/Paper/2.png"></p><p>采用micro-buffer除了可以降低更新一致性的复杂性以外，还可以避免缓冲区溢出，悬垂指针等软件bug对NVMM带来的影响。同时，由于micro-buffer位于DRAM中，可以借鉴一些内存调试工具的思想来实现更强的数据保护，例如，Pangolin在每个micro-buffer的header中插入了一个64-bit的canary，在将object写回之前，通过验证其完整性提供对NVMM的保护。</p><p>由于XOR运算的可交换性，在进行parity更新时，可以实现较为简单的增量更新，单个object的修改带来的parity更新过程如下图所示：</p><p><img src="/img/article/Paper/3.png"></p><p>当一个Range Column中的多个object同时进行更新时，就带来了parity update的一致性挑战，同时由于Atomic XOR要慢于Vectorized XOR，为了保证更新一致性同时兼顾计算效率，论文引入了一种细粒度锁——parity range-locks。对于Small updates (&lt; 8KB)，共享range-lock，采用atomic XOR instructions并行更新parity；对于Large updates (≥ 8KB)，独占range-lock，采用Vectorized XOR串行更新parity。</p><p>与libpmemobj的replication方式相比，Pangolin使用更小的存储空间实现了类似的性能，同时保证了crash consistency，除此之外还支持software级别的错误检测和在线恢复。但在容错度方面，Pangolin仅支持任意位置的单4KB page的错误，或者位于不同Range Column的object错误，这是由parity本身的性质导致的，为了提高容错度，就需要减少行数，增加列数以减少错误overlap的概率，但过多的列数同样会增加计算parity的开销。除此之外，Pangolin仅支持多线程同时修改不同的object，不支持多线程同时修改同一个object，这同时也是libpmemobj存在的问题。</p><p>论文链接：<a href="https://www.usenix.org/conference/atc19/presentation/zhang-lu">https://www.usenix.org/conference/atc19/presentation/zhang-lu</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容错</tag>
      
      <tag>PM</tag>
      
      <tag>NVM</tag>
      
      <tag>PMDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/03/hello-world/"/>
    <url>/2021/07/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
