<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[LintCode] 4 丑数Ⅱ</title>
    <link href="/2021/07/04/Lintcode-4/"/>
    <url>/2021/07/04/Lintcode-4/</url>
    
    <content type="html"><![CDATA[<p>设计一个算法，找出只含素因子<code>2</code>，<code>3</code>，<code>5</code> 的第 <em>n</em> 小的数。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>设计一个算法，找出只含素因子<code>2</code>，<code>3</code>，<code>5</code> 的第 <em>n</em> 小的数。</p><p>符合条件的数如：<code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12...</code></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：<span class="hljs-number">9</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：<span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当前丑数必定是之前某个丑数的2倍、3倍、或者5倍。</p><p>初始化丑数数组ugly[0]=1，从第一位开始分别乘以2、3、5得到后续丑数。</p><p>注意得到丑数后需要保证数组的大小顺序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: return a  integer as description.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">int</span> ugly[n];<br>        ugly[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">int</span> p2,p3,p5;<br>        p2=p3=p5=<span class="hljs-number">0</span>;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>        &#123;<br>            ugly[i]=min(min(ugly[p2]*<span class="hljs-number">2</span>,ugly[p3]*<span class="hljs-number">3</span>),min(ugly[p2]*<span class="hljs-number">2</span>,ugly[p5]*<span class="hljs-number">5</span>));<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p2]*<span class="hljs-number">2</span>)<br>                ++p2;<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p3]*<span class="hljs-number">3</span>)<br>                ++p3;<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p5]*<span class="hljs-number">5</span>)<br>                ++p5;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ugly[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://blog.csdn.net/htt789/article/details/79992923">https://blog.csdn.net/htt789/article/details/79992923</a></p>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Count</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 394 硬币排成线</title>
    <link href="/2021/07/04/Lintcode-394/"/>
    <url>/2021/07/04/Lintcode-394/</url>
    
    <content type="html"><![CDATA[<p>有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。请判定先手玩家必胜还是必败?</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。</p><p>请判定先手玩家必胜还是必败?</p><p>若必胜，返回true，否则返回false。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 1</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 4</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 先手玩家第一轮拿走一个硬币，此时还剩三个，这时无论后手玩家拿一个还是两个，下一次先手玩家都可以把剩下的硬币拿完。</span><br></code></pre></td></tr></table></figure><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a><strong>挑战</strong></h4><p>O(1) 时间复杂度且O(1) 存储。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>博弈论问题：</p><p>有 n 个硬币排成一条线。两个参赛者 A 和 B 轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。</p><p>当n=1时，A必胜（拿1个）；</p><p>当n=2时，A必胜（拿2个）；</p><p>当n=3时，A必败（A不管拿1个还是2个，B都可以将剩下的棋子一次拿完）；</p><p>当n=4时，A必胜（A拿1个，剩3个，转化为B先手必败）；</p><p>当n=5时，A必胜（A拿2个，同上）；</p><p>当n=6时，A必败（A不管拿1个还是2个，B都可以将棋子拿到只剩3个，转化为A先手必败）；</p><p>……</p><p>当n=9时，A必败（A不管拿1个还是2个，B都可以将棋子拿到只剩6个，转化为A先手必败）；</p><p>综上，</p><p>当n%3 == 0时，A不管拿1个还是2个，B都可以将棋子转化为A先手必败的情况；</p><p>同样，当n%3 != 0时，A都可以将棋子转化为B先手必败的情况。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: A boolean which equals to true if the first player will win</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">firstWillWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>关于博弈论问题的总结，见<a href="https://www.cnblogs.com/Wolfycz/p/8430991.html">浅谈算法——博弈论</a></p>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Lintcode] 3 统计数字</title>
    <link href="/2021/07/04/Lintcode-3/"/>
    <url>/2021/07/04/Lintcode-3/</url>
    
    <content type="html"><![CDATA[<p>计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">k</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：在[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]中，我们发现<span class="hljs-number">1</span>出现了<span class="hljs-number">1</span>次(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：k = <span class="hljs-number">1</span>, n = <span class="hljs-number">12</span><br>输出：<span class="hljs-number">5</span><br>解释：在[<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4,5,6,7</span>,<span class="hljs-number">8,9,10,11</span>,<span class="hljs-number">12</span>]中，我们发现<span class="hljs-number">1</span>出现了<span class="hljs-number">5</span>次(<span class="hljs-number">1,10,11,12</span>)(注意<span class="hljs-number">11</span>中有两个<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>以k = 5为例：</p><p>每10位产生1个数，[0,9]有一个5，[10,19]有一个15，[20,29]有一个25</p><p>每100位产生10个数，[0,99]有10个5，即[50,59]，[100,199]有10个5，即[150,159]</p><p>每1000位产生100个数，[0,999]有100个5，即[500,599]</p><p>以此类推……</p><p>当 n = 2169，k = 1 时：</p><p>个位：9前面有216个10，故有216个1，又因为9&gt;1，所以一共有216+1=217个1</p><p>十位：6前面有21个100，100中有10个1，故有21*10=210个1，又因为6&gt;1，所以包含了10~19的10个1，一共有210+10=220个1</p><p>百位：1前面有2个1000，1000中有100个1，故有2*100=200个1，这里1==1，也就是多了100~169一共70个1，一共有200+70=270个1</p><p>千位：2&gt;1，包含了1000~1999的1000个1</p><p>一共有217+220+270+1000=1707个1</p><p>但当 k = 0 时的情况不同，当 n = 2169，k = 0 时：</p><p>个位：9前面有216个10，故有216个0，又因为9&gt;0，所以一共有216+1=217个0</p><p>十位：6前面有21个100，100中有10个0，故有21*10=210个0，但00<del>09的情况不存在，故只有210-10=200个0，又因为6&gt;0，所以包含了00</del>09的10个0，一共有200+10=210个0</p><p>百位：1前面有2个1000，1000中有100个0，故有2*100=200个1，但000<del>099的情况不存在，故只有200-100=100个0，这里1&gt;0，所以包含了000</del>099的100个0，一共有100+100=200个0</p><p>千位：2&gt;0，但0000~0999的情况不存在</p><p>一共有217+210+200=627个0</p><p>因此，当计算从右往左数第 i位包含 k 的个数时：</p><p>若第 i 位大于k，则结果为**第 i 位左边所有数字乘以10<sup>i-1</sup>次方 **+ <strong>10<sup>i-1</sup>次方</strong></p><p>若第 i 位小于k，则结果为<strong>第 i 位左边的所有数字乘以10<sup>i-1</sup>次方</strong></p><p>若第 i 位等于k，则结果为**第 i 位左边所有数字乘以10<sup>i-1</sup>次方 **+ <strong>右边的所有数字</strong>+<strong>1</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param k: An integer</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: An integer denote the count of digit k in 1..n</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">digitCounts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">int</span> bit=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前位的权重</span><br>        <span class="hljs-keyword">int</span> bitnum=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前位的具体数字</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//k出现的总次数</span><br>        <span class="hljs-keyword">int</span> val=n;<span class="hljs-comment">//赋值val用于计算每位</span><br>        <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//处理k=0时候的情况，t为要减去的情况之和</span><br>    <br>        <span class="hljs-keyword">if</span>(n==k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(val!=<span class="hljs-number">0</span>)<br>        &#123;<br>            bitnum=val-(val/<span class="hljs-number">10</span>)*<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(bitnum&lt;k)<br>                sum+=(val/<span class="hljs-number">10</span>)*bit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bitnum==k)<br>                sum+=(val/<span class="hljs-number">10</span>)*bit+n-val*bit+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                sum+=(val/<span class="hljs-number">10</span>)*bit+bit;<br>            t+=bit;<br>            bit*=<span class="hljs-number">10</span>;<br>            val/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            sum-=(t<span class="hljs-number">-1</span>);<span class="hljs-comment">//减1是去掉bit为1时的情况，即0的情况存在</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol><li><a href="https://blog.csdn.net/Flag_died/article/details/104062613">https://blog.csdn.net/Flag_died/article/details/104062613</a></li><li><a href="https://blog.csdn.net/weixin_42316707/article/details/86510114">https://blog.csdn.net/weixin_42316707/article/details/86510114</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Count</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 1089 有效的括号字符串</title>
    <link href="/2021/07/04/Lintcode-1089/"/>
    <url>/2021/07/04/Lintcode-1089/</url>
    
    <content type="html"><![CDATA[<p>给定一个只包含三种类型字符的字符串：’(‘、’)’ 和 ‘*’，编写一个函数来检查该字符串是否有效。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个只包含三种类型字符的字符串：’(‘、’)’ 和 ‘*’，编写一个函数来检查该字符串是否有效。我们通过以下规则定义字符串的有效性：</p><ol><li>任何左括号 ‘(‘ 必须有一个相应的右括号 ‘)’</li><li>任何右括号 ‘)’ 必须有一个相应的左括号 ‘(‘</li><li>左括号 ‘(‘ 必须在相应的右括号 ‘)’ 之前</li><li>‘*’ 可以被视为单个右括号 ‘ )’ 或单个左括号 ‘(‘ 或空字符串</li><li>空字符串也有效。</li></ol><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>样例1：输入：”()”           输出：true<br>样例2：输入：”(*)”         输出：true          解释：’*‘看做是空<br>样例3：输入：”(*))”        输出：true          解释: ‘*’ 当作’(‘</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历字符数组，遇到左括号，左括号索引放入左括号栈，遇到*号，索引放入star栈。当遇到右括号的时候，这就先优先从左括号出栈，如果左括号栈空了，再从star栈出栈。</p><p>需要注意，*(这个情况，他不是有效括号。基于这个问题，栈就不能单纯的存字符括号和*号了，必须存放索引，当遍历完后，需要比较索引。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> lintcode;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>Stack&lt;Integer&gt; leftParenthesis=<span class="hljs-keyword">new</span> Stack&lt;&gt; ();<span class="hljs-comment">//左括号</span><br>Stack&lt;Integer&gt; starParenthesis=<span class="hljs-keyword">new</span> Stack&lt;&gt; ();<span class="hljs-comment">//星号</span><br><span class="hljs-keyword">char</span> []arr=s.toCharArray();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br><span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>leftParenthesis.push(i);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>starParenthesis.push(i);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span>(!leftParenthesis.isEmpty())<br>leftParenthesis.pop();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!starParenthesis.isEmpty())<br>starParenthesis.pop();<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//遍历完字符数组后，需要判断左括号栈，和*栈了。针对*（这中情况,左括号在*号的右边</span><br><span class="hljs-keyword">while</span>(!leftParenthesis.isEmpty()&amp;&amp;!starParenthesis.isEmpty()) &#123;<br><span class="hljs-keyword">if</span>(leftParenthesis.peek()&gt;starParenthesis.peek())<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">else</span> &#123;<br>leftParenthesis.pop();<br>starParenthesis.pop();<br>&#125;<br>&#125;<br><span class="hljs-comment">//最后只需要判断左括号是否有剩余。最后如果剩下的都是***,那都是有效括号空字符</span><br><span class="hljs-keyword">return</span> leftParenthesis.isEmpty();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>Scanner in=<span class="hljs-keyword">new</span> Scanner(System.in);<br>String s=in.nextLine();<br><span class="hljs-keyword">boolean</span> k=checkValidString(s);<br>System.out.print(k);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="Java-Stack类"><a href="#Java-Stack类" class="headerlink" title="Java Stack类"></a>Java Stack类</h5><p>栈是Vector的一个子类，它实现了一个标准的后进先出的栈；</p><p>堆栈只定义了默认构造函数，用来创建一个空栈；</p><p>堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-comment">//测试堆栈是否为空。</span></span><br><span class="hljs-function">Object <span class="hljs-title">peek</span><span class="hljs-params">()</span><span class="hljs-comment">//查看堆栈顶部的对象，但不从堆栈中移除它。</span></span><br><span class="hljs-function">Object <span class="hljs-title">pop</span><span class="hljs-params">()</span><span class="hljs-comment">//移除堆栈顶部的对象，并作为此函数的值返回该对象。</span></span><br><span class="hljs-function">Object <span class="hljs-title">push</span><span class="hljs-params">(Object element)</span><span class="hljs-comment">//把项压入堆栈顶部。</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Object element)</span><span class="hljs-comment">//返回对象在堆栈中的位置，以 1 为基数。</span></span><br></code></pre></td></tr></table></figure><h5 id="Java-输入输出流"><a href="#Java-输入输出流" class="headerlink" title="Java 输入输出流"></a>Java 输入输出流</h5><p>Java的输出函数很简单，直接调用System类的out对象的print函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(a);<span class="hljs-comment">//输出变量a的值</span><br>System.out.print(<span class="hljs-string">&quot;214214&quot;</span>);<span class="hljs-comment">//输出字符串</span><br>System.out.print(<span class="hljs-string">&quot;123&quot;</span>+a);<span class="hljs-comment">//混合输出字符串和变量值</span><br></code></pre></td></tr></table></figure><p>Java的输入函数还是Scanner类最好用，它既可以读字符，也可以读字符串和整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> </span>&#123; <br>         Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的姓名：&quot;</span>); <br>         String name = sc.nextLine(); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的年龄：&quot;</span>); <br>         <span class="hljs-keyword">int</span> age = sc.nextInt(); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的工资：&quot;</span>); <br>         <span class="hljs-keyword">float</span> salary = sc.nextFloat(); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Java</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Notes] 常用命令</title>
    <link href="/2021/07/04/note-command/"/>
    <url>/2021/07/04/note-command/</url>
    
    <content type="html"><![CDATA[<p>常用命令 of Linux, Redis, Vim, Git, SSH and MarkDown</p><span id="more"></span><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>查看PCI-E插槽使用情况：dmidecode | grep -1 PCI</li><li>查看显卡信息：lspci | grep -i vga</li></ul><ul><li>复制粘贴文件：　　cp  [选项]  源文件或目录  目标文件或目录</li><li>剪切粘贴文件：　　mv  [选项]  源文件或目录  目标文件或目录</li></ul><ul><li>创建文件夹： mkdir</li><li>删除文件：rm -rf 文件名   <ul><li>//-r 就是向下递归，不管有多少级目录，一并删除</li><li>//-f 就是直接强行删除，不作任何提示的意思）</li></ul></li><li>查看文件系统： df</li></ul><ul><li><p>压缩：tar -zcvf archive_name.tar.gz filename</p></li><li><p>解压缩：</p><ul><li>tar -zxvf archive_name.tar.gz (-C new_dir)</li><li>unzip zipped_file.zip (-d unzipped_directory)</li></ul></li></ul><ul><li><p>复制文件：</p><ul><li>cp dir1/a.doc dir2  表示将dir1下的a.doc文件复制到dir2目录下</li><li>cp -r dir1 dir2     表示将dir1及其dir1下所包含的文件复制到dir2下</li><li>cp -r dir1/. dir2   表示将dir1下的文件复制到dir2,不包括dir1目录</li></ul></li></ul><ul><li>修改kernel配置参数：<ul><li>目录：cd proc/sys/kernel</li><li>修改：echo value &gt;修改项（不能使用vim，vim需要copy一份修改后在覆盖，权限不够）</li></ul></li></ul><ul><li>查看各用户占用空间：sudo du -sh /home/*</li></ul><hr><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>获取redis中所有的key：  redis 127.0.0.1:6379&gt; KEYS *</li><li>删除数据库所有数据：FLUSHALL</li><li>redis-server  直接启动</li><li>redis-server  配置路径  如redis-server  /etc/redis.conf<br>这时候要后台启动的话就需要配置redis.conf中的daemonize no改为yes</li><li>停止   redis-cli (-a 密码) -h 127.0.0.1 -p 6379 shutdown</li><li>确认是否启动，使用  ps -ef|grep redis</li><li>查看结点状态：INFO</li><li>查看集群状态：CLUSTER INFO</li><li>查看集群的槽：cluster slots</li><li>redis集群，添加新节点：CLUSTER MEET 127.0.0.1 7002</li><li>Redis清空数据库：flushall</li></ul><hr><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul><li><p>有三个快捷键可以进入编辑模式，a i o</p></li><li><p>保存并退出，输入:wq</p></li><li><p>查找字符串，输入/或者？加需要查找的字符串，查看下一个，小写n，跳转到上一个，大写N</p></li><li><p>[Ctrl] + [f]    屏幕『向下』移动一页，相当于 [Page Down]按键<br>[Ctrl] + [b]    屏幕『向上』移动一页，相当于 [Page Up] 按键</p></li><li><p>:num   直接跳到第num行。</p></li><li><p>多行注释：</p><ol><li><p>进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来</p></li><li><p>按大写字母I，再插入注释符，例如//</p></li><li><p>按esc键就会全部注释了</p></li></ol></li><li><p>取消多行注释：</p><ol><li>进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列</li><li>按字母j，或者k选中注释符号</li><li>按d键就可全部取消注释</li></ol></li><li><p>定位到文件尾：G</p></li></ul><hr><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>初始化：git init</li><li>添加到github远程仓库：git remote add origin 仓库链接</li><li>下载代码：git clone URL</li><li>查看分支：git branch （-a 查看所有分支）</li><li>切换分支：git checkout 分支名</li><li>如果我们修改了本地的某个文件但是没有提交，这时我们用 $ git status可以看到提示</li><li>批量提交修改：git add –all</li><li>拉取：git pull</li><li>上传：git push origin master</li></ul><hr><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>在终端连接ssh的断开关闭退出的方法</p><ol><li>输入logout    比较正式的退出方式</li><li>输入exit        等同于方法1</li><li>Ctrl + D        等同于方法1，方便快捷</li></ol><hr><h3 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h3><ul><li>上下标：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">H&lt;sub&gt;<span class="hljs-number">2</span>&lt;/sub&gt;O  CO&lt;sub&gt;<span class="hljs-number">2</span>&lt;/sub&gt;<br>爆米&lt;sup&gt;TM&lt;/sup&gt;<br></code></pre></td></tr></table></figure><p>显示效果为：H<sub>2</sub>O    CO<sub>2</sub>    爆米<sup>TM</sup></p><ul><li>显示空行：&amp;nbsp;</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Command</tag>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
      <tag>Redis</tag>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Tutorial] Pycharm+PyQt5</title>
    <link href="/2021/07/04/Pycharm-PyQt5/"/>
    <url>/2021/07/04/Pycharm-PyQt5/</url>
    
    <content type="html"><![CDATA[<h4 id="Pycharm-amp-PyQt5-环境搭建记录"><a href="#Pycharm-amp-PyQt5-环境搭建记录" class="headerlink" title="Pycharm &amp; PyQt5 环境搭建记录"></a>Pycharm &amp; PyQt5 环境搭建记录</h4><span id="more"></span><h5 id="Step1：环境搭建"><a href="#Step1：环境搭建" class="headerlink" title="Step1：环境搭建"></a>Step1：环境搭建</h5><ul><li><p>过程参考：</p><p><a href="https://www.jb51.net/article/162137.htm">https://www.jb51.net/article/162137.htm</a></p><p><a href="https://blog.csdn.net/px41834/article/details/79383985">https://blog.csdn.net/px41834/article/details/79383985</a></p></li><li><p>主要问题：</p><ol><li><p>designer.exe路径问题：</p><p>designer的路径可能并不是..\venv\Lib\site-packages\pyqt5-tools\designer.exe，建议使用Everything直接搜索designer.exe，有可能位于..\venv\Lib\site-packages\qt5_applications\Qt\bin</p></li><li><p>无法启动qtdesigner：</p><p><img src="/img/article/Tutorial/20200616112822349.png"></p><p>添加环境变量，参考<a href="http://www.xiaoheidiannao.com/15127.html">http://www.xiaoheidiannao.com/15127.html</a></p><p>变量名：QT_QPA_PLATFORM_PLUGIN_PATH</p><p>变量值：与designer同级的plugins文件夹路径</p></li></ol></li></ul><h5 id="Step2：designer入门"><a href="#Step2：designer入门" class="headerlink" title="Step2：designer入门"></a>Step2：designer入门</h5><ul><li><p>参考：</p><p><a href="https://blog.csdn.net/azuremouse/article/details/90338961">https://blog.csdn.net/azuremouse/article/details/90338961</a></p><p><a href="https://blog.csdn.net/yl_best/article/details/83825223">https://blog.csdn.net/yl_best/article/details/83825223</a></p></li></ul><h5 id="Step3：Table-View入门"><a href="#Step3：Table-View入门" class="headerlink" title="Step3：Table View入门"></a>Step3：Table View入门</h5><ul><li>参考：<a href="https://blog.csdn.net/jia666666/article/details/81624259">https://blog.csdn.net/jia666666/article/details/81624259</a></li></ul><h5 id="Step4：生成可执行文件"><a href="#Step4：生成可执行文件" class="headerlink" title="Step4：生成可执行文件"></a>Step4：生成可执行文件</h5><ul><li>参考：<a href="https://blog.csdn.net/qq_32939413/article/details/86564611">https://blog.csdn.net/qq_32939413/article/details/86564611</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Qt</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Redis] Redis持久化机制的源码分析</title>
    <link href="/2021/07/04/Redis-code/"/>
    <url>/2021/07/04/Redis-code/</url>
    
    <content type="html"><![CDATA[<p>文章基于Redis-4.0版本，介绍AOF持久化策略的具体实现过程，包括AOF持久化的触发，文件追加、写入、同步的代码实现，启动阶段的数据还原实现，AOF重写的触发与实现等。</p><span id="more"></span><hr><h3 id="1-AOF持久化"><a href="#1-AOF持久化" class="headerlink" title="1 AOF持久化"></a>1 AOF持久化</h3><h4 id="1-1-AOF触发"><a href="#1-1-AOF触发" class="headerlink" title="1.1 AOF触发"></a>1.1 AOF触发</h4><p>Redis执行命令时都会先建立一个客户端，然后由客户端去和服务器连接， redis的命令执行中有一个核心部分，就是call()方法，call函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* src/server.c/call() */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(client *c, <span class="hljs-keyword">int</span> flags)</span></span><br></code></pre></td></tr></table></figure><p>其中client代表客户端，flags是一个特殊标识，当flags为CLIENT_FORCE_AOF时，标志着强制服务器将当前执行的命令写入到AOF文件当中。除此之外，在call函数执行过程中还维护着一个变量dirty用来标识当前执行的命令操作是否改变服务器数据，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">dirty = server.dirty;  <br>c-&gt;cmd-&gt;proc(c);  <span class="hljs-comment">//实际的命令执行函数</span><br>dirty = server.dirty-dirty;  <br><span class="hljs-keyword">if</span> (dirty &lt; <span class="hljs-number">0</span>) dirty = <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure><p>通过以上两个判断条件，就可以设置命令传播的标识，进而调用传播方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dirty)   propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);  <br><span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)   propagate_flags |= PROPAGATE_AOF;  <br> <br><span class="hljs-comment">//Call propagate only if at least one of AOF/REPL propagation is needed</span><br><span class="hljs-keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))  <br>    propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);  <br></code></pre></td></tr></table></figure><h4 id="1-2-文件追加、写入、同步"><a href="#1-2-文件追加、写入、同步" class="headerlink" title="1.2 文件追加、写入、同步"></a>1.2 文件追加、写入、同步</h4><p>propagate()函数的作用是将命令传播给AOF以及slave中（slave是Redis集群部分的内容），propagate()将命令传播到AOF中是通过调用feedAppendOnlyFile()函数实现的，在调用该函数之前，首先需要检查AOF机制是否已开启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* src/server.c/propagate() */</span>  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">propagate</span><span class="hljs-params">(struct redisCommand *cmd, <span class="hljs-keyword">int</span> dbid, robj **argv, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;  <br> <span class="hljs-keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)  <br>     feedAppendOnlyFile(cmd,dbid,argv,argc);  <br>&#125; <br></code></pre></td></tr></table></figure><p>feedAppendOnlyFile()位于src/aof.c中，该函数将命令追加至aof_buf中，如果正在执行AOF重写，还需要将其追加到重写缓冲区中，具体实现过程包括以下四个步骤：</p><ol><li>使用 SELECT 命令，显式设置数据库，确保之后的命令被设置到正确的数据库；</li><li>将命令和命令参数还原为协议格式；</li><li>将命令追加到aof_buf中（使用函数sdscatlen()实现，该函数为Redis自定义的，针对sds结构实现的追加函数，位于src/sds.c中）；</li><li>如果BGREWRITEAOF正在进行，还需要将命令追加到重写缓存中（使用函数aofRewriteBufferAppend()实现，位于src/aof.c中）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Append to the AOF buffer. This will be flushed on disk just before </span><br><span class="hljs-comment"> * of re-entering the event loop, so before the client will get a </span><br><span class="hljs-comment"> * positive reply about the operation performed. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_state == AOF_ON)  <br>server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));  <br><span class="hljs-comment">/* If a background append only file rewriting is in progress we want to </span><br><span class="hljs-comment"> * accumulate the differences between the child DB and the current one </span><br><span class="hljs-comment"> * in a buffer, so that when the child process will do its work we </span><br><span class="hljs-comment"> * can append the differences to the new append only file. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>)  <br>aofRewriteBufferAppend((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)buf,sdslen(buf));<br></code></pre></td></tr></table></figure><p>AOF文件的写入和同步采用的是src/aof.c/flushAppendOnlyFile函数。该函数在src/server.c/beforeSleep中会被调用，而beforeSleep函数是在处理client事件之前执行的（事件循环函数aeMain先执行beforesleep，然后执行aeProcessEvents），因此，server.aof_buf中的值会在向client发送响应之前刷新到磁盘上。</p><p>flushAppendOnlyFile(int force)函数的具体实现过程中，根据不同的同步策略以及后台是否有正在进行fsync操作，共分为以下几种情况：</p><ol><li>判断是否写入，同步策略为everysecond（server.aof_fsync == AOF_FSYNC_EVERYSEC），且没有要求强制写入（!force），且有fsync正在后台执行：<ul><li>之前没有推迟过write操作，则记录下时间，直接返回（如果此时强制执行write的话，服务器主线程将阻塞在write上面）；</li><li>之前推迟过write操作，但推迟时间&lt;2秒，直接返回；</li><li>推迟时间&gt;=2秒，不返回，继续执行。</li></ul></li><li>执行写入操作，调用aofWrite函数</li><li>判断是否同步：<ul><li>同步策略为always（server.aof_fsync == AOF_FSYNC_ALWAYS），执行同步操作（调用aof_fsync函数，在Linux系统，该函数使用fdatasync实现，在其他系统中，使用fsync实现）。</li><li>同步策略为everysecond，且距离上次写操作已超过1秒，且没有fsync在后台执行，则后台执行同步操作（调用aof_background_fsync函数）。</li></ul></li></ol><hr><h3 id="2-数据还原"><a href="#2-数据还原" class="headerlink" title="2 数据还原"></a>2 数据还原</h3><p>Redis启动之后，在src/server.c/main()函数中调用loadDataFromDisk()，当AOF为开启状态时，该函数会继续调用src/aof.c/loadAppendOnlyFile()，在该函数中会通过创建伪客户端的方式，遍历执行AOF文件的命令，还原数据库状态。</p><hr><h3 id="3-AOF重写"><a href="#3-AOF重写" class="headerlink" title="3 AOF重写"></a>3 AOF重写</h3><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由server.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等；</li><li>清理数据库中的过期键值对；</li><li>关闭和清理连接失效的客户端；</li><li>触发BGSAVE或者AOF重写，并处理之后由BGSAVE和AOF重写引发的子进程停止。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每秒调用server.hz次，直到服务器关闭为止。</p><h4 id="3-1-BGSAVE和BGREWRITEAOF的触发"><a href="#3-1-BGSAVE和BGREWRITEAOF的触发" class="headerlink" title="3.1 BGSAVE和BGREWRITEAOF的触发"></a>3.1 BGSAVE和BGREWRITEAOF的触发</h4><p>在serverCron()函数中与Redis持久化相关的检查以及处理流程如下图所示，具体实现包括：</p><p><img src="/img/article/Redis/image-20200607224305949.png" alt="serverCron中相关操作流程"></p><ul><li>如果BGSAVE和BGREWRITEAOF都没有在执行，但是有一个BGREWRITEAOF在等待（server.aof_rewrite_scheduled），那么执行BGREWRITEAOF（调用函数src/aof.c/rewriteAppendOnlyFileBackground）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Start a scheduled AOF rewrite if this was requested by the user while </span><br><span class="hljs-comment"> * a BGSAVE was in progress. */</span>  <br><span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;  <br>server.aof_rewrite_scheduled) &#123;  <br>rewriteAppendOnlyFileBackground();  <br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>如果BGSAVE和BGREWRITEAOF都没有在执行，而且也没有BGREWRITEAOF在等待，那么检查是否需要执行它们<ul><li>BGSAVE：检查m秒内是否发生了超过n次的变化（对应于配置文件中的save m n），BGSAVE操作由函数src/rdb.c/rdbSaveBackground实现</li><li>BGREWRITEAOF：<ul><li>当前AOF文件大小大于执行 BGREWRITEAOF 所需的最小大小，即server.aof_rewrite_min_size</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-perc）</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Trigger an AOF rewrite if needed */</span>  <br><span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;  <br>    server.aof_rewrite_perc &amp;&amp;  <br>    server.aof_current_size &gt; server.aof_rewrite_min_size)  &#123;  <br>    <span class="hljs-comment">// 上一次完成 AOF 写入之后，AOF 文件的大小  </span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = server.aof_rewrite_base_size ?  <br>                 server.aof_rewrite_base_size : <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// AOF 文件当前的体积相对于 base 的体积的百分比  </span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> growth = (server.aof_current_size*<span class="hljs-number">100</span>/base) - <span class="hljs-number">100</span>;  <br><span class="hljs-comment">// 如果增长体积的百分比超过了 growth ，那么执行 BGREWRITEAOF  </span><br><span class="hljs-keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123; <br>    rewriteAppendOnlyFileBackground();  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>如果存在BGSAVE或者BGREWRITEAOF在执行，则检查其是否已经执行完毕，并处理因此而引发的子进程停止</li><li>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写人的数据，那么serverCron会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync </span><br><span class="hljs-comment"> * completed. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_flush_postponed_start)   <br> flushAppendOnlyFile(<span class="hljs-number">0</span>);  <br></code></pre></td></tr></table></figure><p>在serverCron函数中会通过检查BGREWRITEAOF的两个自动触发条件来执行AOF重写，但除此之外，用户还可以通过在客户端输入bgwriteaof命令来手动触发AOF重写。与其他命令的处理流程相同，bgwriteaof命令对应的命令处理函数为aof.c/bgrewriteaofCommand()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bgrewriteaofCommand</span><span class="hljs-params">(client *c)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>) &#123;  <br>        addReplyError(c,<span class="hljs-string">&quot;Background AOF rewriting already in progress&quot;</span>);  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (server.rdb_child_pid != <span class="hljs-number">-1</span>) &#123;  <br>    server.aof_rewrite_scheduled = <span class="hljs-number">1</span>;  <br>    addReplyStatus(c,<span class="hljs-string">&quot;Background append only file rewriting scheduled&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rewriteAppendOnlyFileBackground() == C_OK) &#123;  <br>    addReplyStatus(c,<span class="hljs-string">&quot;Background append only file rewriting started&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>    addReply(c,shared.err);  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>在该函数中，AOF重写也是通过调用rewriteAppendOnlyFileBackground函数来实现的。但当有BGSAVE在执行时（server.rdb_child_pid != -1），BGREWRITEAOF会等待（server.aof_rewrite_scheduled = 1），如前文所述，等待的BGREWRITEAOF会在serverCron函数中被执行。</p><h4 id="3-2-AOF重写的实现"><a href="#3-2-AOF重写的实现" class="headerlink" title="3.2 AOF重写的实现"></a>3.2 AOF重写的实现</h4><p>AOF重写是依靠rewriteAppendOnlyFileBackground函数实现的，该函数的处理过程包括：</p><ol><li>使用fork创建一个子进程；</li><li>子进程调用aof.c/rewriteAppendOnlyFile函数在一个临时文件里写入能够反映当前db状态的数据和命令，此时父进程会把这段时间内执行的能够改变当前db数据的命令放到重写缓冲区中；</li><li>当子进程退出时，父进程收到信号，将上面的重写缓冲区中的数据flush到临时文件中，然后将临时文件rename成新的aof文件。</li></ol><p>子进程调用rewriteAppendOnlyFile函数后，在该函数中会继续调用实际的重写函数aof.c/rewriteAppendOnlyFileRio，该函数遍历db中的每条数据，取出键，取出值，然后根据值的类型选择适当的命令来进行保存，然后写入并同步AOF临时文件中。</p><p>在serverCron函数中，会周期性的检查BGREWRITEAOF子进程是否已退出，当父进程收到退出信号后，会调用aof.c/backgroundRewriteDoneHandler函数完成后续处理，包括：</p><ol><li>调用aof.c/aofRewriteBufferWrite函数，将累计的AOF重写缓冲区的内容追加到AOF临时文件中；</li><li>将AOF 临时文件rename，替换现有的AOF文件。</li></ol><p>参考内容：《Redis设计与实现》，黄健宏著</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持久化</tag>
      
      <tag>AOF</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Redis] Redis的数据持久化机制</title>
    <link href="/2021/07/04/Redis-AOF-RDB/"/>
    <url>/2021/07/04/Redis-AOF-RDB/</url>
    
    <content type="html"><![CDATA[<p>Redis作为一种高性能的内存数据库，将全部数据储存在内存当中，因此一旦发生服务器宕机或系统崩溃，存储的数据就会全部丢失。为了解决这一问题，Redis提供RDB和AOF两种持久化机制，将数据同步到磁盘中。当系统或服务器重启时，利用持久化文件即可恢复数据，有效的避免了数据丢失问题。</p><span id="more"></span><hr><h3 id="1-RDB持久化"><a href="#1-RDB持久化" class="headerlink" title="1 RDB持久化"></a>1 RDB持久化</h3><p>RDB持久化方式是通过快照（snapshotting）完成的，当符合一定条件时，redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当redis重启时，redis会读取RDB持久化生成的二进制文件进行数据恢复。</p><h4 id="1-1-RDB持久化的触发条件"><a href="#1-1-RDB持久化的触发条件" class="headerlink" title="1.1 RDB持久化的触发条件"></a>1.1 RDB持久化的触发条件</h4><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><p>save命令触发</p><p>客户端执行save命令，该命令强制redis执行快照，这时候redis处于阻塞状态，不会响应任何其他客户端发来的请求，直到RDB快照文件执行完毕，所以请慎用。</p></li><li><p>bgsave命令触发</p><p>bgsave，即后台保存，当执行bgsave命令时，redis会fork出一个子进程来执行快照生成操作，需要注意的redis是在fork子进程这个简短的时间redis是阻塞的，当子进程创建完成以后redis继续响应客户端请求。执行过程如下图所示：</p></li></ul><p><img src="/img/article/Redis/RDB%E6%8C%81%E4%B9%85%E5%8C%96bgsave%E8%BF%87%E7%A8%8B.jpg" alt="RDB持久化bgsave过程"></p><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p><p>自动触发实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。</p><p>除了save m n以外，还有一些其他情况会触发bgsave， 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点。执行shutdown命令时，也会自动执行rdb持久化。</p><h4 id="1-2-RDB持久化的优缺点"><a href="#1-2-RDB持久化的优缺点" class="headerlink" title="1.2 RDB持久化的优缺点"></a>1.2 RDB持久化的优缺点</h4><ul><li>优点：<ol><li>RDB是一个非常紧凑的文件，体积小，易于传输，适合灾难恢复。</li><li>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O操作。</li><li>RDB在恢复大数据集时的速度比AOF的恢复速度要快。</li></ol></li><li>缺点：<ol><li>RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。</li><li>RDB需要fork子进程将内容持久化在磁盘上。如果数据集很大，fork可能很耗时，并且如果数据集很大且CPU性能不佳，则可能导致Redis停止服务几毫秒甚至一秒钟。AOF机制也需要fork，但可以调整重写日志的频率。</li></ol></li></ul><hr><h3 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2 AOF持久化"></a>2 AOF持久化</h3><p>除了RDB持久化功能外，Redis还提供了AOF持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><h4 id="2-1-AOF持久化的实现"><a href="#2-1-AOF持久化的实现" class="headerlink" title="2.1 AOF持久化的实现"></a>2.1 AOF持久化的实现</h4><p>AOF 持久化功能的实现可以分为命令追加，文件写入，文件同步三个步骤。</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。其中aof_buf的定义位于redisServer结构体中。</p><h5 id="AOF文件的同步和写入"><a href="#AOF文件的同步和写入" class="headerlink" title="AOF文件的同步和写入"></a>AOF文件的同步和写入</h5><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里，所以在服务器每次结束一个事件循环之前，他都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和同步到AOF文件中。</p><p>针对flushAppendOnlyFile函数的行为，redis提供了三种同步策略，由配置参数appendfsync来决定，各个不同值产生的行为如下所示：</p><ul><li>everysec：将aof_buf 缓冲区中的所有内容写入到AOF 文件，如果上次同步AOF 文件的时间距离现在超过一秒钟，那么再次对AOF 文件进行同步，并且这个同步操作是由一个专门负责执行的。</li><li>always：将aof_buf 缓冲区的所有内容写入并同步到AOF 文件中。</li><li>no：将aof_buf 缓冲区的所有内容写入到AOF 文件中，但并不对AOF 文件进行同步，合适同步由操作系统决定。</li></ul><p>从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失1秒的命令数据。这是折中的方案，兼顾性能和数据安全，也是redis的默认配置。</p><p>always模式在每次写操作后都调用fsync方法强制内核将数据写入到aof文件。这种情况下虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。</p><p>no模式下的同步交给操作系统write函数去执行，这种情况下，AOF文件写入速度是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</p><h4 id="2-2-AOF文件的载入与数据还原"><a href="#2-2-AOF文件的载入与数据还原" class="headerlink" title="2.2 AOF文件的载入与数据还原"></a>2.2 AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。Redis读取AOF文件并还原数据库的详细步骤如下图所示。</p><p><img src="/img/article/Redis/AOF%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E8%BF%87%E7%A8%8B.jpg" alt="AOF文件载入过程"></p><p>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和网络连接的客户端执行命令的效果完全一样。</p><h4 id="2-3-AOF重写"><a href="#2-3-AOF重写" class="headerlink" title="2.3 AOF重写"></a>2.3 AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，同时使用AOF文件来进行数据还原所需的时间也越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><p>假设服务器对某一个key执行了多个写命令，那么服务器为了保存该key的当前状态，必须将这些写命令全部写入AOF文件中。如果服务器想要用尽量少的命令来记录该key的状态，最简单高效的办法不是去读取和分析现有AOF文件的内容，而是直接从数据库中读取该key对应的value值，然后用一条写命令命令来代替原有的多个写命令即可，这就是AOF重写功能的实现原理。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。在Redis4.0版本中，AOF_REWRITE_ITEMS_PER_CMD常量的值为64。</p><h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用AOF重写函数的话，那么在重写期间，服务期将无法处理客户端发来的命令请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>但子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区（aof_rewrite_buf），这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF文件触发条件可分为手动触发和自动触发：</p><ul><li>手动触发：客户端执行bgrewriteaof命令。</li><li>自动触发：自动触发通过以下两个配置协作生效：<ol><li>uto-aof-rewrite-min-size: AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64MB。</li><li>auto-aof-rewrite-percentage：当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。</li></ol></li></ul><p>每次当serverCron（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：</p><ul><li>没有BGSAVE命令（RDB持久化）/AOF持久化在执行；</li><li>没有BGREWRITEAOF在进行；</li><li>当前AOF文件大小要大于server.aof_rewrite_min_size的值；</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-perc）<br>整个AOF后台重写过程如下所示：</li></ul><p><img src="/img/article/Redis/AOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.jpg" alt="AOF后台重写过程"></p><ol><li>开始bgrewriteaof</li><li>主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。</li><li>主进程fork完子进程继续接受客户端请求，此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区aof_rewrite_buf。</li><li>子进程通过内存快照，按照命令重写策略写入到新的AOF文件。<ul><li>子进程写完新的AOF文件后，向主进程发信号。</li><li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li></ul></li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><h4 id="2-4-AOF持久化的优缺点"><a href="#2-4-AOF持久化的优缺点" class="headerlink" title="2.4 AOF持久化的优缺点"></a>2.4 AOF持久化的优缺点</h4><ul><li>优点：<ol><li> 更高的数据安全性，同时有不同的同步策略</li><li> AOF包含一个格式清晰、易于理解的日志文件记录所有的修改操作。</li><li> AOF机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。同时Redis还提供redis-check-aof工具来解决数据一致性的问题。</li></ol></li><li>缺点：<ol><li> 数据文件体积较大，即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。</li><li> 相对RDB方式，AOF模式的恢复速度慢于RDB。</li><li> 由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但仍在一个可以接受的范围内。</li></ol></li></ul><hr><h3 id="3-RDB-AOF混合持久化"><a href="#3-RDB-AOF混合持久化" class="headerlink" title="3 RDB-AOF混合持久化"></a>3 RDB-AOF混合持久化</h3><p>从redis4.0开始，添加了新的混合持久化方式，这里介绍的混合持久化就是同时结合RDB持久化以及AOF持久化混合写入AOF文件。这样做的好处是可以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据，缺点是AOF里面的RDB部分就是压缩格式不再是AOF格式，可读性差。</p><p>混合持久化同样也是通过bgrewriteAOF完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入AOF文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说，新的AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。</p><p>当我们开启了混合持久化时，启动redis依然优先加载AOF文件，AOF文件加载可能有两种情况如下：</p><ul><li>AOF文件开头是RDB的格式，先加载RDB内容再加载剩余的AOF。</li><li>AOF文件开头不是RDB的格式，直接以AOF格式加载整个文件。</li></ul><p>参考内容：<br>[1]《redis系列–redis4.0深入持久化》，<a href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a><br>[2]《Redis设计与实现》，黄健宏著</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持久化</tag>
      
      <tag>RDB</tag>
      
      <tag>AOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Paper] Pangolin: A Fault-Tolerant Persistent Memory Programming Library</title>
    <link href="/2021/07/03/Pangolin/"/>
    <url>/2021/07/03/Pangolin/</url>
    
    <content type="html"><![CDATA[<p>论文发表于2019年USENIX Annual Technical Conference(ATC)中，提出了一种能实现fault tolerance的，基于DAX-map的NVMM编程库——Pangolin。论文出自加州大学圣地亚哥分校的Non-Volatile Systems Laboratory(NVSL)。该实验室专注于新型内存技术的研究，近年来在ATC、FAST、ASPLOS等A类会议发表多篇高水平论文，包括基于非易失性内存的测试框架、文件系统、编程库等多个方向。</p><p>非易失性内存(NVMM)的一个重要特征就是支持DAX模式，在该模式下，实现崩溃一致性(Crash consistency)和容错(Fault tolerance)都十分必要，近年来已经有诸多实验团队针对Crash consistency提出解决方法，但对于Fault tolerance的研究还比较稀少。在这样的背景下，论文提出了一种能实现fault tolerance的，基于DAX-map的NVMM编程库——Pangolin，用于应用程序在NVMM中构建复杂的数据结构。Pangolin结合了校验和(checksum)、奇偶校验(parity)和微缓冲(micro-buffer)三种技术，能够同时避免media error和software bug带来的损害，并支持自动检测和在线恢复。与现阶段支持fault tolerance的NVMM编程库相比，Pangolin使用了的很小的存储开销，达到了类似的性能。</p><p>现阶段的NVM编程库libpmemobj通过副本(replication)的方法来实现fault tolerance，但这样会带来100%的空间开销，为了减少存储开销，Pangolin提出了下图所示的数据保护模式：</p><p><img src="/img/article/Paper/1.png"></p><p>对于一个NVMM pool，其中pool和zone的元数据PM和ZM，以及Log区域仍然采用replication的方式进行容错，因为这一部分所占的存储空间很小（对于1GB的pool，只占用0.1%的存储空间）。对于chunk区域，在逻辑上将其组织为二维数组的形式，最后一行作为parity data进行奇偶检验，chunk的元数据CM和object data都通过parity来进行数据容错。同时，Pangolin还在每个object header中开辟了32 bit的区域存放checksum，进行object data的错误检测。</p><p>为了降低更新checksum和parity所带来的的一致性挑战，Pangolin引入了micro-buffer。当需要修改一个PMEM中的object时，需要在micro-buffer中做一个object的shadow copy，对object的修改将在DRAM中进行，修改完成后重新计算checksum，将checksum和修改操作记录到Log中，随后进行parity的更新操作，当以上步骤都完成以后，将修改后的object写回PMEM中。一次完整的流程如下图所示：</p><p><img src="/img/article/Paper/2.png"></p><p>采用micro-buffer除了可以降低更新一致性的复杂性以外，还可以避免缓冲区溢出，悬垂指针等软件bug对NVMM带来的影响。同时，由于micro-buffer位于DRAM中，可以借鉴一些内存调试工具的思想来实现更强的数据保护，例如，Pangolin在每个micro-buffer的header中插入了一个64-bit的canary，在将object写回之前，通过验证其完整性提供对NVMM的保护。</p><p>由于XOR运算的可交换性，在进行parity更新时，可以实现较为简单的增量更新，单个object的修改带来的parity更新过程如下图所示：</p><p><img src="/img/article/Paper/3.png"></p><p>当一个Range Column中的多个object同时进行更新时，就带来了parity update的一致性挑战，同时由于Atomic XOR要慢于Vectorized XOR，为了保证更新一致性同时兼顾计算效率，论文引入了一种细粒度锁——parity range-locks。对于Small updates (&lt; 8KB)，共享range-lock，采用atomic XOR instructions并行更新parity；对于Large updates (≥ 8KB)，独占range-lock，采用Vectorized XOR串行更新parity。</p><p>与libpmemobj的replication方式相比，Pangolin使用更小的存储空间实现了类似的性能，同时保证了crash consistency，除此之外还支持software级别的错误检测和在线恢复。但在容错度方面，Pangolin仅支持任意位置的单4KB page的错误，或者位于不同Range Column的object错误，这是由parity本身的性质导致的，为了提高容错度，就需要减少行数，增加列数以减少错误overlap的概率，但过多的列数同样会增加计算parity的开销。除此之外，Pangolin仅支持多线程同时修改不同的object，不支持多线程同时修改同一个object，这同时也是libpmemobj存在的问题。</p><p>论文链接：<a href="https://www.usenix.org/conference/atc19/presentation/zhang-lu">https://www.usenix.org/conference/atc19/presentation/zhang-lu</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容错</tag>
      
      <tag>PM</tag>
      
      <tag>NVM</tag>
      
      <tag>PMDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/03/hello-world/"/>
    <url>/2021/07/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
