<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[LeetCode] 每日一题 July 11~20</title>
    <link href="/2021/07/11/LeetCode-July-11-20/"/>
    <url>/2021/07/11/LeetCode-July-11-20/</url>
    
    <content type="html"><![CDATA[<ul><li>July 11 - 274. H 指数；</li></ul><span id="more"></span><hr><h3 id="July-11-274-H-指数"><a href="#July-11-274-H-指数" class="headerlink" title="July 11 - 274. H 指数"></a>July 11 - 274. H 指数</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</p><p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：citations = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">3</span> <br>解释：给定数组表示研究者总共有 <span class="hljs-number">5</span> 篇论文，每篇论文相应的被引用了 <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span> 次。<br>     由于研究者有 <span class="hljs-number">3</span> 篇论文每篇 至少 被引用了 <span class="hljs-number">3</span> 次，其余两篇论文每篇被引用 不多于 <span class="hljs-number">3</span> 次，所以她的 h 指数是 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">提示：如果 h 有多种可能的值，h 指数是其中最大的那个。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们可以将初始的 H 指数 h 设为 0，然后将引用次数排序，并且对排序后的数组从大到小遍历。</p><p>根据 H 指数的定义，如果当前 H 指数为 h 并且在遍历过程中找到当前值 citations[i]&gt;h，则说明我们找到了一篇被引用了至少 h+1 次的论文，所以将现有的 h 值加 1。继续遍历直到 h 无法继续增大。最后返回 h 作为最终答案。</p><p>时间复杂度：O(nlogn)，其中 n 为数组 citations 的长度。即为排序的时间复杂度。</p><p>空间复杂度：O(logn)，其中 n 为数组 citations 的长度。即为排序的空间复杂度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(citations.<span class="hljs-built_in">rbegin</span>(),citations.<span class="hljs-built_in">rend</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:citations)&#123;<br>            <span class="hljs-keyword">if</span>(a&gt;h)&#123;<br>                h++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 每日一题 July 1~10</title>
    <link href="/2021/07/04/LeetCode-July-1-10/"/>
    <url>/2021/07/04/LeetCode-July-1-10/</url>
    
    <content type="html"><![CDATA[<ul><li>July 1 - LCP 07. 传递信息；</li><li>July 2 - 1833. 雪糕的最大数量；</li><li>July 3 - 根据字符出现频率排序；</li><li>July 4 - 645. 错误的集合；</li><li>July 5 - 726. 原子的数量；</li><li>July 6 - 1418. 点菜展示表；</li><li>July 7 - 1711. 大餐计数；</li><li>July 8 - 930. 和相同的二元子数组；</li><li>July 9 - 面试题 17.10. 主要元素；</li><li>July 10 - 981. 基于时间的键值存储</li></ul><span id="more"></span><hr><h3 id="July-1-LCP-07-传递信息"><a href="#July-1-LCP-07-传递信息" class="headerlink" title="July 1 - LCP 07. 传递信息"></a>July 1 - LCP 07. 传递信息</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ul><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li><li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ul><p>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：n = <span class="hljs-number">5</span>, relation = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>说明：信息从小 A 编号 <span class="hljs-number">0</span> 处开始，经 <span class="hljs-number">3</span> 轮传递，到达编号 <span class="hljs-number">4</span>。共有 <span class="hljs-number">3</span> 种方案，分别是 <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：n = <span class="hljs-number">3</span>, relation = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">限制：<br>    <span class="hljs-number">2</span> &lt;= n &lt;= <span class="hljs-number">10</span><br><span class="hljs-number">1</span> &lt;= k &lt;= <span class="hljs-number">5</span><br><span class="hljs-number">1</span> &lt;= relation.length &lt;= <span class="hljs-number">90</span>, 且 relation[i].length == <span class="hljs-number">2</span><br><span class="hljs-number">0</span> &lt;= relation[i][<span class="hljs-number">0</span>],relation[i][<span class="hljs-number">1</span>] &lt; n 且 relation[i][<span class="hljs-number">0</span>] != relation[i][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h5><p>可以把传信息的关系看成有向图，每个玩家对应一个节点，每个传信息的关系对应一条有向边。如果 x 可以向 y 传信息，则对应从节点 x 到节点 y 的一条有向边。寻找从编号 0 的玩家经过 k 轮传递到编号 n−1 的玩家处的方案数，等价于在有向图中寻找从节点 0 到节点 n−1 的长度为 k 的路径数，同一条路径可以重复经过同一个节点。</p><p>可以使用深度优先搜索计算方案数。从节点 0 出发做深度优先搜索，每一步记录当前所在的节点以及经过的轮数，当经过 k 轮时，如果位于节点 n−1，则将方案数加 1。搜索结束之后，即可得到总的方案数。</p><p>时间复杂度：O(n^k)。最多需要遍历 k 层，每层遍历最多有 O(n) 个分支。</p><p>空间复杂度：O(n+m+k)。其中 m 为 relation 数组的长度。空间复杂度主要取决于图的大小和递归调用栈的深度，保存有向图信息所需空间为 O(n+m)，递归调用栈的深度不会超过 k。</p><h5 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h5><p>也可以使用广度优先搜索计算方案数。从节点 0 出发做广度优先搜索，当遍历到 k 层时，如果位于节点 n−1，则将方案数加 1。搜索结束之后，即可得到总的方案数。</p><h5 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h5><p>这道题是计数问题，可以使用动态规划的方法解决。</p><p>定义动态规划的状态 dp[i][j]为经过 i 轮传递到编号 j 的玩家的方案数，其中 0≤i≤k，0≤j&lt;n。</p><p>由于从编号 0 的玩家开始传递，当 i=0 时，一定位于编号 0 的玩家，不会传递到其他玩家，因此动态规划的边界情况如下：</p><p><img src="/img/article/LeetCode/image-20210701213904825.png"></p><p>对于传信息的关系 [src,dst]，如果第 i轮传递到编号 src 的玩家，则第 i+1 轮可以从编号 src 的玩家传递到编号 dst 的玩家。因此在计算 dp[i+1][dst] 时，需要考虑可以传递到编号 dst 的所有玩家。由此可以得到动态规划的状态转移方程，其中 0≤i&lt;k：</p><p><img src="/img/article/LeetCode/image-20210701214033003.png"></p><p>最终得到 dp[k][n−1] 即为总的方案数。</p><p>时间复杂度：O(km)。其中 m为 relation 数组的长度。</p><p>空间复杂度是 O(kn)。由于当 i&gt;0 时，dp[i][] 的值只和dp[i−1][] 的值有关，因此可以将二维数组变成一维数组，将空间复杂度优化到 O(n)。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//动态规划</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : relation) &#123;<br>                <span class="hljs-keyword">int</span> src = edge[<span class="hljs-number">0</span>], dst = edge[<span class="hljs-number">1</span>];<br>                dp[i + <span class="hljs-number">1</span>][dst] += dp[i][src];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//动态规划空间复杂度优化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : relation) &#123;<br>                <span class="hljs-keyword">int</span> src = edge[<span class="hljs-number">0</span>], dst = edge[<span class="hljs-number">1</span>];<br>                next[dst] += dp[src];<br>            &#125;<br>            dp = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析 | 菜鸟教程 (runoob.com)</a></p><hr><h3 id="July-2-1833-雪糕的最大数量"><a href="#July-2-1833-雪糕的最大数量" class="headerlink" title="July 2 - 1833. 雪糕的最大数量"></a>July 2 - 1833. 雪糕的最大数量</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>排序 + 贪心</p><p>对数组costs 排序，然后按照从小到大的顺序遍历数组元素，对于每个元素，如果该元素不超过剩余的硬币数，则将硬币数减去该元素值，表示购买了这支雪糕，当遇到一个元素超过剩余的硬币数时，结束遍历，此时购买的雪糕数量即为可以购买雪糕的最大数量。</p><p>时间复杂度：O(nlogn)，其中 n 是数组 costs 的长度。对数组排序的时间复杂度是 O(nlogn)，遍历数组的时间复杂度是O(n)，因此总时间复杂度是O(nlogn)。</p><p>空间复杂度：O(logn)，其中 n 是数组 costs 的长度。空间复杂度主要取决于排序使用的额外空间。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxIceCream</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; costs, <span class="hljs-keyword">int</span> coins)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(costs.<span class="hljs-built_in">begin</span>(),costs.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a : costs)&#123;<br>            <span class="hljs-keyword">if</span>(a&lt;=coins)&#123;<br>                i++;<br>                coins-=a;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-3-根据字符出现频率排序"><a href="#July-3-根据字符出现频率排序" class="headerlink" title="July 3 - 根据字符出现频率排序"></a>July 3 - 根据字符出现频率排序</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入:<br><span class="hljs-string">&quot;tree&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;eert&quot;</span><br><br>解释:<br><span class="hljs-string">&#x27;e&#x27;</span>出现两次，<span class="hljs-string">&#x27;r&#x27;</span>和<span class="hljs-string">&#x27;t&#x27;</span>都只出现一次。<br>因此<span class="hljs-string">&#x27;e&#x27;</span>必须出现在<span class="hljs-string">&#x27;r&#x27;</span>和<span class="hljs-string">&#x27;t&#x27;</span>之前。此外，<span class="hljs-string">&quot;eetr&quot;</span>也是一个有效的答案。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入:<br><span class="hljs-string">&quot;Aabb&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;bbAa&quot;</span><br><br>解释:<br>此外，<span class="hljs-string">&quot;bbaA&quot;</span>也是一个有效的答案，但<span class="hljs-string">&quot;Aabb&quot;</span>是不正确的。<br>注意<span class="hljs-string">&#x27;A&#x27;</span>和<span class="hljs-string">&#x27;a&#x27;</span>被认为是两种不同的字符。<br></code></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题目要求将给定的字符串按照字符出现的频率降序排序，因此需要首先遍历字符串，统计每个字符出现的频率，然后每次得到频率最高的字符，生成排序后的字符串。</p><p>可以使用哈希表记录每个字符出现的频率，将字符去重后存入列表，再将列表中的字符按照频率降序排序。</p><p>生成排序后的字符串时，遍历列表中的每个字符，则遍历顺序为字符按照频率递减的顺序。对于每个字符，将该字符按照出现频率拼接到排序后的字符串。例如，遍历到字符 c，该字符在字符串中出现了 freq 次，则将 freq 个字符 c 拼接到排序后的字符串。</p><p>时间复杂度：O(n+klogk)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数，这道题中 s 只包含大写字母、小写字母和数字，因此 k=26+26+10=62。遍历字符串统计每个字符出现的频率需要 O(n) 的时间。将字符按照出现频率排序需要 O(klogk) 的时间。生成排序后的字符串，需要遍历 k 个不同字符，需要 O(k) 的时间，拼接字符串需要 O(n) 的时间。因此总时间复杂度是 O(n+klogk+k+n)=O(n+klogk)。</p><p>空间复杂度：O(n+k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于哈希表、列表和生成的排序后的字符串。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;a, pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;freq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m:s)&#123;<br>            freq[m]++;<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;&gt;vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:freq)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(n);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),cmp);<br>        string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:vec)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k.second;i++)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(k.first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>reference to non-static member function must be called</p><p><a href="https://blog.csdn.net/u010982765/article/details/79021426">错误：reference to non-static member function must be called_initHeart的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/AnnieKim/archive/2011/12/04/2275589.html">恼人的函数指针（二）：指向类成员的指针 - AnnieKim - 博客园 (cnblogs.com)</a></p></blockquote><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/xs18952904/article/details/81463822">C++中 sort() 的使用_LucienShui-CSDN博客</a></p><p><a href="https://blog.csdn.net/sevenjoin/article/details/81937695">C++ pair的基本用法总结（整理）_sevenjoin的博客-CSDN博客_c++ pair</a></p><p><a href="https://blog.csdn.net/hk2291976/article/details/51037095">关联容器：unordered_map详细介绍（附可运行代码）_Voidsky-CSDN博客</a></p><p><a href="http://c.biancheng.net/view/6826.html">C++ STL vector添加元素（push_back()和emplace_back()）详解 (biancheng.net)</a></p><hr><h3 id="July-4-645-错误的集合"><a href="#July-4-645-错误的集合" class="headerlink" title="July 4 - 645. 错误的集合"></a>July 4 - 645. 错误的集合</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。</p><p>给定一个数组 nums 代表了集合 S 发生错误后的结果。</p><p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2,4]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,3,4,6,5]</span><br>输出：<span class="hljs-comment">[3,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,5,3,2</span>,<span class="hljs-number">2,7,6,4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：排序</strong></p><p>将数组排序之后，比较每对相邻的元素，即可找到错误的集合。</p><p>寻找重复的数字较为简单，如果相邻的两个元素相等，则该元素为重复的数字。</p><p>寻找丢失的数字相对复杂，可能有以下两种情况：</p><ul><li>如果丢失的数字大于 1 且小于 n，则一定存在相邻的两个元素的差等于 2，这两个元素之间的值即为丢失的数字；</li><li>如果丢失的数字是 1 或 n，则需要另外判断。</li></ul><p>时间复杂度：O(nlogn)，其中 nn 是数组 nums 的长度。排序需要 O(nlogn) 的时间，遍历数组找到错误的集合需要 O(n) 的时间，因此总时间复杂度是 O(nlogn)。</p><p>空间复杂度：O(logn)，其中 n 是数组 nums 的长度。排序需要 O(logn) 的空间。</p><p><strong>方法二：哈希表</strong></p><p>重复的数字在数组中出现 2 次，丢失的数字在数组中出现 0 次，其余的每个数字在数组中出现 1 次。因此可以使用哈希表记录每个元素在数组中出现的次数，然后遍历从 1 到 n 的每个数字，分别找到出现 2 次和出现 0 次的数字，即为重复的数字和丢失的数字。</p><p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。需要遍历数组并填入哈希表，然后遍历从 1 到 n 的每个数寻找错误的集合。</p><p>空间复杂度：O(n)，其中 n 是数组nums 的长度。需要创建大小为 O(n) 的哈希表。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法1，排序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">int</span> curr = nums[i];<br>            <span class="hljs-keyword">if</span>(curr == prev)&#123;<br>                result[<span class="hljs-number">0</span>] = prev;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curr - prev &gt; <span class="hljs-number">1</span>)&#123;<br>                result[<span class="hljs-number">1</span>] = curr - <span class="hljs-number">1</span>;<br>            &#125;<br>            prev = curr;<br>        &#125; <br>        <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>] != n)&#123;<br>            result[<span class="hljs-number">1</span>] = n;<br>        &#125;       <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法2，hash表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;num_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:nums)&#123;<br>            num_map[i]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(num_map[j] == <span class="hljs-number">0</span>)&#123;<br>                result[<span class="hljs-number">1</span>] = j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num_map[j] == <span class="hljs-number">2</span>)&#123;<br>                result[<span class="hljs-number">0</span>] = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li>注意数组边界，前后两个数字相比时，注意后面一个数字不要越界</li><li>注意特殊情况，当缺少1或者n时的特殊处理</li></ul><hr><h3 id="July-5-726-原子的数量"><a href="#July-5-726-原子的数量" class="headerlink" title="July 5 - 726. 原子的数量"></a>July 5 - 726. 原子的数量</h3><hr><h3 id="July-6-1418-点菜展示表"><a href="#July-6-1418-点菜展示表" class="headerlink" title="July 6 - 1418. 点菜展示表"></a>July 6 - 1418. 点菜展示表</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。</p><p>请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">displayTable</span>(vector&lt;vector&lt;string&gt;&gt; &amp;orders) &#123;<br>        <span class="hljs-comment">// 从订单中获取餐品名称和桌号，统计每桌点餐数量</span><br>        unordered_set&lt;string&gt; nameSet;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt;&gt; foodsCnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;order : orders) &#123;<br>            nameSet.<span class="hljs-built_in">insert</span>(order[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">int</span> id = <span class="hljs-built_in">stoi</span>(order[<span class="hljs-number">1</span>]);<br>            ++foodsCnt[id][order[<span class="hljs-number">2</span>]];<br>        &#125;<br><br>        <span class="hljs-comment">// 提取餐品名称，并按字母顺序排列</span><br>        <span class="hljs-keyword">int</span> n = nameSet.<span class="hljs-built_in">size</span>();<br>        vector&lt;string&gt; names;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;name : nameSet) &#123;<br>            names.<span class="hljs-built_in">push_back</span>(name);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(names.<span class="hljs-built_in">begin</span>(), names.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">// 提取桌号，并按餐桌桌号升序排列</span><br>        <span class="hljs-keyword">int</span> m = foodsCnt.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ids;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[id, _] : foodsCnt) &#123;<br>            ids.<span class="hljs-built_in">push_back</span>(id);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(ids.<span class="hljs-built_in">begin</span>(), ids.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">// 填写点菜展示表</span><br>        vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">table</span>(m + <span class="hljs-number">1</span>, vector&lt;string&gt;(n + <span class="hljs-number">1</span>));<br>        table[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Table&quot;</span>;<br>        <span class="hljs-built_in">copy</span>(names.<span class="hljs-built_in">begin</span>(), names.<span class="hljs-built_in">end</span>(), table[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">int</span> id = ids[i];<br>            <span class="hljs-keyword">auto</span> &amp;cnt = foodsCnt[id];<br>            table[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">to_string</span>(id);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                table[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">to_string</span>(cnt[names[j]]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> table;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-7-1711-大餐计数"><a href="#July-7-1711-大餐计数" class="headerlink" title="July 7 - 1711. 大餐计数"></a>July 7 - 1711. 大餐计数</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p><p>你可以搭配 任意 两道餐品做一顿大餐。</p><p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p><p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p><h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为<span class="hljs-number"> 4 </span>、8 、8 和<span class="hljs-number"> 16 </span>，都是<span class="hljs-number"> 2 </span>的幂。<br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为<span class="hljs-number"> 3 </span>种 (1,1) ，9 种 (1,3) ，和<span class="hljs-number"> 3 </span>种 (1,7) 。<br></code></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>朴素的解法是遍历数组 deliciousness 中的每对元素，对于每对元素，计算两个元素之和是否等于 2 的幂。该解法的时间复杂度为 O(n^2)，会超出时间限制。</p><p>上述朴素解法存在同一个元素被重复计算的情况，因此可以使用哈希表减少重复计算，降低时间复杂度。具体做法是，使用哈希表存储数组中的每个元素的出现次数，遍历到数组 deliciousness 中的某个元素时，在哈希表中寻找与当前元素的和等于 2 的幂的元素个数，然后用当前元素更新哈希表。由于遍历数组时，哈希表中已有的元素的下标一定小于当前元素的下标，因此任意一对元素之和等于 2 的幂的元素都不会被重复计算。</p><p>令 maxVal 表示数组 deliciousness 中的最大元素，则数组中的任意两个元素之和都不会超过   maxVal×2。令 maxSum=maxVal×2，则任意一顿大餐的美味程度之和为不超过 maxSum 的某个 2 的幂。</p><p>对于某个特定的 2 的幂 sum，可以在 O(n) 的时间内计算数组 deliciousness 中元素之和等于 sum 的元素对的数量。数组 deliciousness 中的最大元素 maxVal 满足 maxVal≤C，其中 C=2^20，则不超过 maxSum 的 2 的幂有 O(logmaxSum)=O(logmaxVal)=O(logC) 个，因此可以在 O(nlogC) 的时间内计算数组 deliciousness 中的大餐数量。</p><p>时间复杂度：O(nlogC)，其中 n 是数组 deliciousness 的长度，C 是数组 deliciousness 中的元素值上限，这道题中 C=2^20 。需要遍历数组 deliciousness 一次，对于其中的每个元素，需要 O(logC) 的时间计算包含该元素的大餐数量，因此总时间复杂度是 O(nlogC)。</p><p>空间复杂度：O(n)，其中 n 是数组 deliciousness 的长度。需要创建哈希表，哈希表的大小不超过 n。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; deliciousness)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxVal =  *<span class="hljs-built_in">max_element</span>(deliciousness.<span class="hljs-built_in">begin</span>(),deliciousness.<span class="hljs-built_in">end</span>());  <br>        <span class="hljs-keyword">int</span> maxSum = maxVal * <span class="hljs-number">2</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:deliciousness)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=<span class="hljs-number">1</span>; sum&lt;=maxSum; sum*=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">int</span> num = map.<span class="hljs-built_in">count</span>(sum-a)? map[sum-a]:<span class="hljs-number">0</span>;<br>                result = (result + num) % MOD;<br>            &#125;<br>            map[a]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/sevenjoin/article/details/81943864">C++ map用法总结（整理）_sevenjoin的博客-CSDN博客_c++map</a></li><li><a href="https://www.cnblogs.com/sword-/p/8036813.html">C++中Vector求最大值最小值 - 西瓜刀刀刀 - 博客园 (cnblogs.com)</a></li></ul><hr><h3 id="July-8-930-和相同的二元子数组"><a href="#July-8-930-和相同的二元子数组" class="headerlink" title="July 8 - 930. 和相同的二元子数组"></a>July 8 - 930. 和相同的二元子数组</h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,0,1,0,1]</span>, goal = 2<br>输出：4<br>解释：有 4 个满足题目要求的子数组：<span class="hljs-comment">[1,0,1]</span>、<span class="hljs-comment">[1,0,1,0]</span>、<span class="hljs-comment">[0,1,0,1]</span>、<span class="hljs-comment">[1,0,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-attr">goal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：哈希表</strong></p><p>假设原数组的前缀和数组为 sum，且子数组 (i,j] 的区间和为 goal，那么 sum[j]−sum[i]=goal。因此我们可以枚举 j ，每次查询满足该等式的 i 的数量。</p><p>具体地，我们用哈希表记录每一种前缀和出现的次数，假设我们当前枚举到元素 nums[j]，我们只需要查询哈希表中元素 sum[j]−goal 的数量即可，这些元素的数量即对应了以当前 j 值为右边界的满足条件的子数组的数量。最后这些元素的总数量即为所有和为 goal 的子数组数量。</p><p>在实际代码中，我们实时地更新哈希表，以防止出现 i≥j 的情况。</p><p>时间复杂度：O(n)，其中 n 为给定数组的长度。对于数组中的每个元素，我们至多只需要插入到哈希表中中一次。</p><p>空间复杂度：O(n)，其中 n 为给定数组的长度。哈希表中至多只存储 O(n) 个元素。</p><p><strong>方法二：滑动窗口</strong></p><p>注意到对于方法一中每一个 j，满足 sum[j]−sum[i]=goal 的 i 总是落在一个连续的区间中，i 值取区间中每一个数都满足条件。并且随着 j 右移，其对应的区间的左右端点也将右移，这样我们即可使用滑动窗口解决本题。</p><p>具体地，我们令滑动窗口右边界为 right，使用两个左边界 left1 和 left2 表示左区间 [left1 ,left2)，此时有 left2−left1 个区间满足条件。</p><p>在实际代码中，我们需要注意 left1≤left2≤right+1，因此需要在代码中限制 left1和 left2 不超出范围。</p><p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为给定数组的长度。我们至多只需要遍历一次该数组。</p><p>空间复杂度：<em>O</em>(1)，我们只需要常数的空间保存若干变量。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一：哈希表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarraysWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums)&#123;<br>            map[sum]++;<br>            sum += a;<br>            result += map[sum-goal];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法二：滑动窗口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarraysWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> left1 = <span class="hljs-number">0</span>, left2 = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum1 = <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            sum1 += nums[right];<br>            <span class="hljs-keyword">while</span> (left1 &lt;= right &amp;&amp; sum1 &gt; goal) &#123;<br>                sum1 -= nums[left1];<br>                left1++;<br>            &#125;<br>            sum2 += nums[right];<br>            <span class="hljs-keyword">while</span> (left2 &lt;= right &amp;&amp; sum2 &gt;= goal) &#123;<br>                sum2 -= nums[left2];<br>                left2++;<br>            &#125;<br>            ret += left2 - left1;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="July-9-面试题-17-10-主要元素"><a href="#July-9-面试题-17-10-主要元素" class="headerlink" title="July 9 - 面试题 17.10. 主要元素"></a>July 9 - 面试题 17.10. 主要元素</h3><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><p>数组中占比<strong>超过一半</strong>的元素称之为<strong>主要元素</strong>。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。</p><h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,2,5,9</span>,<span class="hljs-number">5,9,5,5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,2]</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">输入：<span class="hljs-selector-attr">[2,2,2,3,3,4,4]</span><br>输出：<span class="hljs-selector-tag">-1</span> (元素<span class="hljs-number">2</span>的个数没有超过一半)<br></code></pre></td></tr></table></figure><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>由于题目要求时间复杂度 O(n) 和空间复杂度 O(1)，因此符合要求的解法只有 Boyer-Moore 投票算法。</p><p>Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。</p><p>如果数组为空，则数组中不存在主要元素；</p><p>如果数组中剩下的元素都相等，则数组中剩下的元素可能为主要元素。</p><p>Boyer-Moore 投票算法的步骤如下：</p><p>维护一个候选主要元素 candidate 和候选主要元素的出现次数 count，初始时 candidate 为任意值，count=0；</p><p>遍历数组 nums 中的所有元素，遍历到元素 x 时，进行如下操作：</p><p>如果 count=0，则将 x 的值赋给 candidate，否则不更新 candidate 的值；</p><p>如果 x=candidate，则将 count 加 1，否则将 count 减 1。</p><p>遍历结束之后，如果数组 nums 中存在主要元素，则 candidate 即为主要元素，否则 candidate 可能为数组中的任意一个元素。</p><p>由于不一定存在主要元素，因此需要第二次遍历数组，验证 candidate 是否为主要元素。第二次遍历时，统计 candidate 在数组中的出现次数，如果出现次数大于数组长度的一半，则 candidate 是主要元素，返回 candidate，否则数组中不存在主要元素，返回 −1。</p><p>为什么当数组中存在主要元素时，Boyer-Moore 投票算法可以确保得到主要元素？</p><p>在 Boyer-Moore 投票算法中，遇到相同的数则将 count 加 1，遇到不同的数则将 count 减 1。根据主要元素的定义，主要元素的出现次数大于其他元素的出现次数之和，因此在遍历过程中，主要元素和其他元素两两抵消，最后一定剩下至少一个主要元素，此时 candidate 为主要元素，且 count≥1。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通解法O(n),O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">int</span> max = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:nums)&#123;<br>            map[a]++;<br>            <span class="hljs-keyword">if</span>(map[a] &gt; max)&#123;<br>                result = a;<br>                max = map[a];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Boyer-Moore 投票算法 O(n),O(1)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums)&#123;<br>            <span class="hljs-keyword">if</span>((count==<span class="hljs-number">0</span>)&amp;&amp;(a!=candidate))&#123;<br>                candidate=a;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == candidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                count--;<br>            &#125;<br>        &#125;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b:nums)&#123;<br>            <span class="hljs-keyword">if</span>(b==candidate)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count&gt;nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> candidate;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><p><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/solution/zhu-yao-yuan-su-by-leetcode-solution-xr1p/">主要元素 - 主要元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><hr><h3 id="July-10-981-基于时间的键值存储"><a href="#July-10-981-基于时间的键值存储" class="headerlink" title="July 10 - 981. 基于时间的键值存储"></a>July 10 - 981. 基于时间的键值存储</h3><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h4><p>创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：</p><ol><li><p>set(string key, string value, int timestamp)</p><ul><li>存储键 key、值 value，以及给定的时间戳 timestamp。</li></ul></li><li><p>get(string key, int timestamp)</p><ul><li>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。</li><li>如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。</li><li>如果没有值，则返回空字符串（””）。</li></ul></li></ol><h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：inputs = [<span class="hljs-string">&quot;TimeMap&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>], inputs = [[],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">3</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar2&quot;</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">5</span>]]<br>输出：[null,null,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,null,<span class="hljs-string">&quot;bar2&quot;</span>,<span class="hljs-string">&quot;bar2&quot;</span>]<br>解释：  <br>TimeMap kv;   <br>kv.set(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 存储键 <span class="hljs-string">&quot;foo&quot;</span> 和值 <span class="hljs-string">&quot;bar&quot;</span> 以及时间戳 timestamp = <span class="hljs-number">1</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>);  <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar&quot;</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar&quot;</span> 因为在时间戳 <span class="hljs-number">3</span> 和时间戳 <span class="hljs-number">2</span> 处没有对应 <span class="hljs-string">&quot;foo&quot;</span> 的值，所以唯一的值位于时间戳 <span class="hljs-number">1</span> 处（即 <span class="hljs-string">&quot;bar&quot;</span>）   <br>kv.set(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar2&quot;</span>, <span class="hljs-number">4</span>);   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar2&quot;</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar2&quot;</span>  <br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：inputs = [<span class="hljs-string">&quot;TimeMap&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>], inputs = [[],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-number">10</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>,<span class="hljs-number">20</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">5</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">10</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">15</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">20</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">25</span>]]<br>输出：[null,null,null,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">提示：所有 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeMap</span>.</span></span>set 操作中的时间戳 timestamps 都是严格递增的。<br></code></pre></td></tr></table></figure><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>哈希表 + 二分查找</strong></p><p>为实现 get 操作，我们需要用一个哈希表存储 set 操作传入的数据。具体地，哈希表的键为字符串 key，值为一个二元组列表，二元组中存储的是时间戳 timestamp 和值 value。</p><p>由于 set 操作中的时间戳都是严格递增的，因此二元组列表中保存的时间戳也是严格递增的，这样我们可以根据 get 操作中的 key 在哈希表中找到对应的二元组列表 pairs，然后根据 timestamp 在 pairs 中二分查找。我们需要找到最大的不超过 timestamp 的时间戳，对此，我们可以二分找到第一个超过 timestamp 的二元组下标 i，若 i&gt;0 则说明目标二元组存在，即 pairs[i−1]，否则二元组不存在，返回空字符串。</p><p>时间复杂度：</p><ul><li>初始化 TimeMap 和 set 操作均为 O(1)；</li><li>get 操作为 O(logn)，其中 n 是 set 操作的次数。最坏情况下 set 操作插入的 key 均相同，这种情况下 get 中二分查找的次数为 O(logn)。</li></ul><p>空间复杂度：O(n)，其中 n 是 set 操作的次数。我们需要使用哈希表保存每一次 set 操作的信息。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeMap</span> &#123;</span><br>    unordered_map&lt;string, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, string&gt;&gt;&gt; m;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimeMap</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(string key, string value, <span class="hljs-keyword">int</span> timestamp)</span> </span>&#123;<br>        m[key].<span class="hljs-built_in">emplace_back</span>(timestamp, value);<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(string key, <span class="hljs-keyword">int</span> timestamp)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> &amp;pairs = m[key];<br>        <span class="hljs-comment">// 使用一个大于所有 value 的字符串</span><br>        <span class="hljs-comment">// 以确保在 pairs 中含有 timestamp 的情况下也返回大于 timestamp 的位置</span><br>        pair&lt;<span class="hljs-keyword">int</span>, string&gt; p = &#123;timestamp, <span class="hljs-built_in">string</span>(&#123;<span class="hljs-number">127</span>&#125;)&#125;;<br>        <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">upper_bound</span>(pairs.<span class="hljs-built_in">begin</span>(), pairs.<span class="hljs-built_in">end</span>(), p);<br>        <span class="hljs-keyword">if</span> (i != pairs.<span class="hljs-built_in">begin</span>()) &#123;<br>            <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>)-&gt;second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hash</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Greedy</tag>
      
      <tag>Sort</tag>
      
      <tag>Boyer-Moore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 4 丑数Ⅱ</title>
    <link href="/2021/07/04/Lintcode-4/"/>
    <url>/2021/07/04/Lintcode-4/</url>
    
    <content type="html"><![CDATA[<p>设计一个算法，找出只含素因子<code>2</code>，<code>3</code>，<code>5</code> 的第 <em>n</em> 小的数。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>设计一个算法，找出只含素因子<code>2</code>，<code>3</code>，<code>5</code> 的第 <em>n</em> 小的数。</p><p>符合条件的数如：<code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12...</code></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：<span class="hljs-number">9</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：<span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当前丑数必定是之前某个丑数的2倍、3倍、或者5倍。</p><p>初始化丑数数组ugly[0]=1，从第一位开始分别乘以2、3、5得到后续丑数。</p><p>注意得到丑数后需要保证数组的大小顺序。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: return a  integer as description.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">int</span> ugly[n];<br>        ugly[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">int</span> p2,p3,p5;<br>        p2=p3=p5=<span class="hljs-number">0</span>;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>        &#123;<br>            ugly[i]=min(min(ugly[p2]*<span class="hljs-number">2</span>,ugly[p3]*<span class="hljs-number">3</span>),min(ugly[p2]*<span class="hljs-number">2</span>,ugly[p5]*<span class="hljs-number">5</span>));<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p2]*<span class="hljs-number">2</span>)<br>                ++p2;<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p3]*<span class="hljs-number">3</span>)<br>                ++p3;<br>            <span class="hljs-keyword">if</span>(ugly[i]==ugly[p5]*<span class="hljs-number">5</span>)<br>                ++p5;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ugly[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://blog.csdn.net/htt789/article/details/79992923">https://blog.csdn.net/htt789/article/details/79992923</a></p>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Count</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 394 硬币排成线</title>
    <link href="/2021/07/04/Lintcode-394/"/>
    <url>/2021/07/04/Lintcode-394/</url>
    
    <content type="html"><![CDATA[<p>有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。请判定先手玩家必胜还是必败?</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。</p><p>请判定先手玩家必胜还是必败?</p><p>若必胜，返回true，否则返回false。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 1</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 4</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 先手玩家第一轮拿走一个硬币，此时还剩三个，这时无论后手玩家拿一个还是两个，下一次先手玩家都可以把剩下的硬币拿完。</span><br></code></pre></td></tr></table></figure><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a><strong>挑战</strong></h4><p>O(1) 时间复杂度且O(1) 存储。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>博弈论问题：</p><p>有 n 个硬币排成一条线。两个参赛者 A 和 B 轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。</p><p>当n=1时，A必胜（拿1个）；</p><p>当n=2时，A必胜（拿2个）；</p><p>当n=3时，A必败（A不管拿1个还是2个，B都可以将剩下的棋子一次拿完）；</p><p>当n=4时，A必胜（A拿1个，剩3个，转化为B先手必败）；</p><p>当n=5时，A必胜（A拿2个，同上）；</p><p>当n=6时，A必败（A不管拿1个还是2个，B都可以将棋子拿到只剩3个，转化为A先手必败）；</p><p>……</p><p>当n=9时，A必败（A不管拿1个还是2个，B都可以将棋子拿到只剩6个，转化为A先手必败）；</p><p>综上，</p><p>当n%3 == 0时，A不管拿1个还是2个，B都可以将棋子转化为A先手必败的情况；</p><p>同样，当n%3 != 0时，A都可以将棋子转化为B先手必败的情况。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: A boolean which equals to true if the first player will win</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">firstWillWin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>关于博弈论问题的总结，见<a href="https://www.cnblogs.com/Wolfycz/p/8430991.html">浅谈算法——博弈论</a></p>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Lintcode] 3 统计数字</title>
    <link href="/2021/07/04/Lintcode-3/"/>
    <url>/2021/07/04/Lintcode-3/</url>
    
    <content type="html"><![CDATA[<p>计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">k</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：在[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]中，我们发现<span class="hljs-number">1</span>出现了<span class="hljs-number">1</span>次(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：k = <span class="hljs-number">1</span>, n = <span class="hljs-number">12</span><br>输出：<span class="hljs-number">5</span><br>解释：在[<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4,5,6,7</span>,<span class="hljs-number">8,9,10,11</span>,<span class="hljs-number">12</span>]中，我们发现<span class="hljs-number">1</span>出现了<span class="hljs-number">5</span>次(<span class="hljs-number">1,10,11,12</span>)(注意<span class="hljs-number">11</span>中有两个<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>以k = 5为例：</p><p>每10位产生1个数，[0,9]有一个5，[10,19]有一个15，[20,29]有一个25</p><p>每100位产生10个数，[0,99]有10个5，即[50,59]，[100,199]有10个5，即[150,159]</p><p>每1000位产生100个数，[0,999]有100个5，即[500,599]</p><p>以此类推……</p><p>当 n = 2169，k = 1 时：</p><p>个位：9前面有216个10，故有216个1，又因为9&gt;1，所以一共有216+1=217个1</p><p>十位：6前面有21个100，100中有10个1，故有21*10=210个1，又因为6&gt;1，所以包含了10~19的10个1，一共有210+10=220个1</p><p>百位：1前面有2个1000，1000中有100个1，故有2*100=200个1，这里1==1，也就是多了100~169一共70个1，一共有200+70=270个1</p><p>千位：2&gt;1，包含了1000~1999的1000个1</p><p>一共有217+220+270+1000=1707个1</p><p>但当 k = 0 时的情况不同，当 n = 2169，k = 0 时：</p><p>个位：9前面有216个10，故有216个0，又因为9&gt;0，所以一共有216+1=217个0</p><p>十位：6前面有21个100，100中有10个0，故有21*10=210个0，但00到09的情况不存在，故只有210-10=200个0，又因为6&gt;0，所以包含了00到09的10个0，一共有200+10=210个0</p><p>百位：1前面有2个1000，1000中有100个0，故有2*100=200个1，但000到099的情况不存在，故只有200-100=100个0，这里1&gt;0，所以包含了000到099的100个0，一共有100+100=200个0</p><p>千位：2&gt;0，但0000到0999的情况不存在</p><p>一共有217+210+200=627个0</p><p>因此，当计算从右往左数第 i位包含 k 的个数时：</p><p>若第 i 位大于k，则结果为**第 i 位左边所有数字乘以10<sup>i-1</sup>次方 **+ <strong>10<sup>i-1</sup>次方</strong></p><p>若第 i 位小于k，则结果为<strong>第 i 位左边的所有数字乘以10<sup>i-1</sup>次方</strong></p><p>若第 i 位等于k，则结果为**第 i 位左边所有数字乘以10<sup>i-1</sup>次方 **+ <strong>右边的所有数字</strong>+<strong>1</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param k: An integer</span><br><span class="hljs-comment">     * @param n: An integer</span><br><span class="hljs-comment">     * @return: An integer denote the count of digit k in 1..n</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">digitCounts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-keyword">int</span> bit=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前位的权重</span><br>        <span class="hljs-keyword">int</span> bitnum=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前位的具体数字</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//k出现的总次数</span><br>        <span class="hljs-keyword">int</span> val=n;<span class="hljs-comment">//赋值val用于计算每位</span><br>        <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//处理k=0时候的情况，t为要减去的情况之和</span><br>    <br>        <span class="hljs-keyword">if</span>(n==k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(val!=<span class="hljs-number">0</span>)<br>        &#123;<br>            bitnum=val-(val/<span class="hljs-number">10</span>)*<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(bitnum&lt;k)<br>                sum+=(val/<span class="hljs-number">10</span>)*bit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bitnum==k)<br>                sum+=(val/<span class="hljs-number">10</span>)*bit+n-val*bit+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                sum+=(val/<span class="hljs-number">10</span>)*bit+bit;<br>            t+=bit;<br>            bit*=<span class="hljs-number">10</span>;<br>            val/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            sum-=(t<span class="hljs-number">-1</span>);<span class="hljs-comment">//减1是去掉bit为1时的情况，即0的情况存在</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol><li><a href="https://blog.csdn.net/Flag_died/article/details/104062613">https://blog.csdn.net/Flag_died/article/details/104062613</a></li><li><a href="https://blog.csdn.net/weixin_42316707/article/details/86510114">https://blog.csdn.net/weixin_42316707/article/details/86510114</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Count</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LintCode] 1089 有效的括号字符串</title>
    <link href="/2021/07/04/Lintcode-1089/"/>
    <url>/2021/07/04/Lintcode-1089/</url>
    
    <content type="html"><![CDATA[<p>给定一个只包含三种类型字符的字符串：’(‘、’)’ 和 ‘*’，编写一个函数来检查该字符串是否有效。</p><span id="more"></span><hr><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个只包含三种类型字符的字符串：’(‘、’)’ 和 ‘*’，编写一个函数来检查该字符串是否有效。我们通过以下规则定义字符串的有效性：</p><ol><li>任何左括号 ‘(‘ 必须有一个相应的右括号 ‘)’</li><li>任何右括号 ‘)’ 必须有一个相应的左括号 ‘(‘</li><li>左括号 ‘(‘ 必须在相应的右括号 ‘)’ 之前</li><li>‘*’ 可以被视为单个右括号 ‘ )’ 或单个左括号 ‘(‘ 或空字符串</li><li>空字符串也有效。</li></ol><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>样例1：输入：”()”           输出：true<br>样例2：输入：”(*)”         输出：true          解释：’*‘看做是空<br>样例3：输入：”(*))”        输出：true          解释: ‘*’ 当作’(‘</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历字符数组，遇到左括号，左括号索引放入左括号栈，遇到*号，索引放入star栈。当遇到右括号的时候，这就先优先从左括号出栈，如果左括号栈空了，再从star栈出栈。</p><p>需要注意，*(这个情况，他不是有效括号。基于这个问题，栈就不能单纯的存字符括号和*号了，必须存放索引，当遍历完后，需要比较索引。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> lintcode;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>Stack&lt;Integer&gt; leftParenthesis=<span class="hljs-keyword">new</span> Stack&lt;&gt; ();<span class="hljs-comment">//左括号</span><br>Stack&lt;Integer&gt; starParenthesis=<span class="hljs-keyword">new</span> Stack&lt;&gt; ();<span class="hljs-comment">//星号</span><br><span class="hljs-keyword">char</span> []arr=s.toCharArray();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<br><span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>leftParenthesis.push(i);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>starParenthesis.push(i);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span>(!leftParenthesis.isEmpty())<br>leftParenthesis.pop();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!starParenthesis.isEmpty())<br>starParenthesis.pop();<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//遍历完字符数组后，需要判断左括号栈，和*栈了。针对*（这中情况,左括号在*号的右边</span><br><span class="hljs-keyword">while</span>(!leftParenthesis.isEmpty()&amp;&amp;!starParenthesis.isEmpty()) &#123;<br><span class="hljs-keyword">if</span>(leftParenthesis.peek()&gt;starParenthesis.peek())<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">else</span> &#123;<br>leftParenthesis.pop();<br>starParenthesis.pop();<br>&#125;<br>&#125;<br><span class="hljs-comment">//最后只需要判断左括号是否有剩余。最后如果剩下的都是***,那都是有效括号空字符</span><br><span class="hljs-keyword">return</span> leftParenthesis.isEmpty();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>Scanner in=<span class="hljs-keyword">new</span> Scanner(System.in);<br>String s=in.nextLine();<br><span class="hljs-keyword">boolean</span> k=checkValidString(s);<br>System.out.print(k);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="Java-Stack类"><a href="#Java-Stack类" class="headerlink" title="Java Stack类"></a>Java Stack类</h5><p>栈是Vector的一个子类，它实现了一个标准的后进先出的栈；</p><p>堆栈只定义了默认构造函数，用来创建一个空栈；</p><p>堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-comment">//测试堆栈是否为空。</span></span><br><span class="hljs-function">Object <span class="hljs-title">peek</span><span class="hljs-params">()</span><span class="hljs-comment">//查看堆栈顶部的对象，但不从堆栈中移除它。</span></span><br><span class="hljs-function">Object <span class="hljs-title">pop</span><span class="hljs-params">()</span><span class="hljs-comment">//移除堆栈顶部的对象，并作为此函数的值返回该对象。</span></span><br><span class="hljs-function">Object <span class="hljs-title">push</span><span class="hljs-params">(Object element)</span><span class="hljs-comment">//把项压入堆栈顶部。</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Object element)</span><span class="hljs-comment">//返回对象在堆栈中的位置，以 1 为基数。</span></span><br></code></pre></td></tr></table></figure><h5 id="Java-输入输出流"><a href="#Java-输入输出流" class="headerlink" title="Java 输入输出流"></a>Java 输入输出流</h5><p>Java的输出函数很简单，直接调用System类的out对象的print函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(a);<span class="hljs-comment">//输出变量a的值</span><br>System.out.print(<span class="hljs-string">&quot;214214&quot;</span>);<span class="hljs-comment">//输出字符串</span><br>System.out.print(<span class="hljs-string">&quot;123&quot;</span>+a);<span class="hljs-comment">//混合输出字符串和变量值</span><br></code></pre></td></tr></table></figure><p>Java的输入函数还是Scanner类最好用，它既可以读字符，也可以读字符串和整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> </span>&#123; <br>         Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的姓名：&quot;</span>); <br>         String name = sc.nextLine(); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的年龄：&quot;</span>); <br>         <span class="hljs-keyword">int</span> age = sc.nextInt(); <br>         System.out.println(<span class="hljs-string">&quot;请输入你的工资：&quot;</span>); <br>         <span class="hljs-keyword">float</span> salary = sc.nextFloat(); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LintCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Java</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Notes] 常用命令</title>
    <link href="/2021/07/04/note-command/"/>
    <url>/2021/07/04/note-command/</url>
    
    <content type="html"><![CDATA[<p>常用命令 of Linux, Redis, Vim, Git, SSH and MarkDown</p><span id="more"></span><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>查看PCI-E插槽使用情况：dmidecode | grep -1 PCI</li><li>查看显卡信息：lspci | grep -i vga</li></ul><ul><li>复制粘贴文件：　　cp  [选项]  源文件或目录  目标文件或目录</li><li>剪切粘贴文件：　　mv  [选项]  源文件或目录  目标文件或目录</li></ul><ul><li>创建文件夹： mkdir</li><li>删除文件：rm -rf 文件名   <ul><li>//-r 就是向下递归，不管有多少级目录，一并删除</li><li>//-f 就是直接强行删除，不作任何提示的意思）</li></ul></li><li>查看文件系统： df</li></ul><ul><li><p>压缩：tar -zcvf archive_name.tar.gz filename</p></li><li><p>解压缩：</p><ul><li>tar -zxvf archive_name.tar.gz (-C new_dir)</li><li>unzip zipped_file.zip (-d unzipped_directory)</li></ul></li></ul><ul><li><p>复制文件：</p><ul><li>cp dir1/a.doc dir2  表示将dir1下的a.doc文件复制到dir2目录下</li><li>cp -r dir1 dir2     表示将dir1及其dir1下所包含的文件复制到dir2下</li><li>cp -r dir1/. dir2   表示将dir1下的文件复制到dir2,不包括dir1目录</li></ul></li></ul><ul><li>修改kernel配置参数：<ul><li>目录：cd proc/sys/kernel</li><li>修改：echo value &gt;修改项（不能使用vim，vim需要copy一份修改后在覆盖，权限不够）</li></ul></li></ul><ul><li>查看各用户占用空间：sudo du -sh /home/*</li></ul><hr><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>获取redis中所有的key：  redis 127.0.0.1:6379&gt; KEYS *</li><li>删除数据库所有数据：FLUSHALL</li><li>redis-server  直接启动</li><li>redis-server  配置路径  如redis-server  /etc/redis.conf<br>这时候要后台启动的话就需要配置redis.conf中的daemonize no改为yes</li><li>停止   redis-cli (-a 密码) -h 127.0.0.1 -p 6379 shutdown</li><li>确认是否启动，使用  ps -ef|grep redis</li><li>查看结点状态：INFO</li><li>查看集群状态：CLUSTER INFO</li><li>查看集群的槽：cluster slots</li><li>redis集群，添加新节点：CLUSTER MEET 127.0.0.1 7002</li><li>Redis清空数据库：flushall</li></ul><hr><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul><li><p>有三个快捷键可以进入编辑模式，a i o</p></li><li><p>保存并退出，输入:wq</p></li><li><p>查找字符串，输入/或者？加需要查找的字符串，查看下一个，小写n，跳转到上一个，大写N</p></li><li><p>[Ctrl] + [f]    屏幕『向下』移动一页，相当于 [Page Down]按键<br>[Ctrl] + [b]    屏幕『向上』移动一页，相当于 [Page Up] 按键</p></li><li><p>:num   直接跳到第num行。</p></li><li><p>多行注释：</p><ol><li><p>进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来</p></li><li><p>按大写字母I，再插入注释符，例如//</p></li><li><p>按esc键就会全部注释了</p></li></ol></li><li><p>取消多行注释：</p><ol><li>进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列</li><li>按字母j，或者k选中注释符号</li><li>按d键就可全部取消注释</li></ol></li><li><p>定位到文件尾：G</p></li></ul><hr><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li>初始化：git init</li><li>添加到github远程仓库：git remote add origin 仓库链接</li><li>下载代码：git clone URL</li><li>查看分支：git branch （-a 查看所有分支）</li><li>切换分支：git checkout 分支名</li><li>如果我们修改了本地的某个文件但是没有提交，这时我们用 $ git status可以看到提示</li><li>批量提交修改：git add –all</li><li>拉取：git pull</li><li>上传：git push origin master</li></ul><hr><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>在终端连接ssh的断开关闭退出的方法</p><ol><li>输入logout    比较正式的退出方式</li><li>输入exit        等同于方法1</li><li>Ctrl + D        等同于方法1，方便快捷</li></ol><hr><h3 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h3><ul><li>上下标：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">H&lt;sub&gt;<span class="hljs-number">2</span>&lt;/sub&gt;O  CO&lt;sub&gt;<span class="hljs-number">2</span>&lt;/sub&gt;<br>爆米&lt;sup&gt;TM&lt;/sup&gt;<br></code></pre></td></tr></table></figure><p>显示效果为：H<sub>2</sub>O    CO<sub>2</sub>    爆米<sup>TM</sup></p><ul><li>显示空行：&amp;nbsp;</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Command</tag>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
      <tag>Redis</tag>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Tutorial] Pycharm+PyQt5</title>
    <link href="/2021/07/04/Pycharm-PyQt5/"/>
    <url>/2021/07/04/Pycharm-PyQt5/</url>
    
    <content type="html"><![CDATA[<h4 id="Pycharm-amp-PyQt5-环境搭建记录"><a href="#Pycharm-amp-PyQt5-环境搭建记录" class="headerlink" title="Pycharm &amp; PyQt5 环境搭建记录"></a>Pycharm &amp; PyQt5 环境搭建记录</h4><span id="more"></span><h5 id="Step1：环境搭建"><a href="#Step1：环境搭建" class="headerlink" title="Step1：环境搭建"></a>Step1：环境搭建</h5><ul><li><p>过程参考：</p><p><a href="https://www.jb51.net/article/162137.htm">https://www.jb51.net/article/162137.htm</a></p><p><a href="https://blog.csdn.net/px41834/article/details/79383985">https://blog.csdn.net/px41834/article/details/79383985</a></p></li><li><p>主要问题：</p><ol><li><p>designer.exe路径问题：</p><p>designer的路径可能并不是..\venv\Lib\site-packages\pyqt5-tools\designer.exe，建议使用Everything直接搜索designer.exe，有可能位于..\venv\Lib\site-packages\qt5_applications\Qt\bin</p></li><li><p>无法启动qtdesigner：</p><p><img src="/img/article/Tutorial/20200616112822349.png"></p><p>添加环境变量，参考<a href="http://www.xiaoheidiannao.com/15127.html">http://www.xiaoheidiannao.com/15127.html</a></p><p>变量名：QT_QPA_PLATFORM_PLUGIN_PATH</p><p>变量值：与designer同级的plugins文件夹路径</p></li></ol></li></ul><h5 id="Step2：designer入门"><a href="#Step2：designer入门" class="headerlink" title="Step2：designer入门"></a>Step2：designer入门</h5><ul><li><p>参考：</p><p><a href="https://blog.csdn.net/azuremouse/article/details/90338961">https://blog.csdn.net/azuremouse/article/details/90338961</a></p><p><a href="https://blog.csdn.net/yl_best/article/details/83825223">https://blog.csdn.net/yl_best/article/details/83825223</a></p></li></ul><h5 id="Step3：Table-View入门"><a href="#Step3：Table-View入门" class="headerlink" title="Step3：Table View入门"></a>Step3：Table View入门</h5><ul><li>参考：<a href="https://blog.csdn.net/jia666666/article/details/81624259">https://blog.csdn.net/jia666666/article/details/81624259</a></li></ul><h5 id="Step4：生成可执行文件"><a href="#Step4：生成可执行文件" class="headerlink" title="Step4：生成可执行文件"></a>Step4：生成可执行文件</h5><ul><li>参考：<a href="https://blog.csdn.net/qq_32939413/article/details/86564611">https://blog.csdn.net/qq_32939413/article/details/86564611</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Qt</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Redis] Redis持久化机制的源码分析</title>
    <link href="/2021/07/04/Redis-code/"/>
    <url>/2021/07/04/Redis-code/</url>
    
    <content type="html"><![CDATA[<p>文章基于Redis-4.0版本，介绍AOF持久化策略的具体实现过程，包括AOF持久化的触发，文件追加、写入、同步的代码实现，启动阶段的数据还原实现，AOF重写的触发与实现等。</p><span id="more"></span><hr><h3 id="1-AOF持久化"><a href="#1-AOF持久化" class="headerlink" title="1 AOF持久化"></a>1 AOF持久化</h3><h4 id="1-1-AOF触发"><a href="#1-1-AOF触发" class="headerlink" title="1.1 AOF触发"></a>1.1 AOF触发</h4><p>Redis执行命令时都会先建立一个客户端，然后由客户端去和服务器连接， redis的命令执行中有一个核心部分，就是call()方法，call函数声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* src/server.c/call() */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(client *c, <span class="hljs-keyword">int</span> flags)</span></span><br></code></pre></td></tr></table></figure><p>其中client代表客户端，flags是一个特殊标识，当flags为CLIENT_FORCE_AOF时，标志着强制服务器将当前执行的命令写入到AOF文件当中。除此之外，在call函数执行过程中还维护着一个变量dirty用来标识当前执行的命令操作是否改变服务器数据，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">dirty = server.dirty;  <br>c-&gt;cmd-&gt;proc(c);  <span class="hljs-comment">//实际的命令执行函数</span><br>dirty = server.dirty-dirty;  <br><span class="hljs-keyword">if</span> (dirty &lt; <span class="hljs-number">0</span>) dirty = <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure><p>通过以上两个判断条件，就可以设置命令传播的标识，进而调用传播方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (dirty)   propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);  <br><span class="hljs-keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)   propagate_flags |= PROPAGATE_AOF;  <br> <br><span class="hljs-comment">//Call propagate only if at least one of AOF/REPL propagation is needed</span><br><span class="hljs-keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))  <br>    propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);  <br></code></pre></td></tr></table></figure><h4 id="1-2-文件追加、写入、同步"><a href="#1-2-文件追加、写入、同步" class="headerlink" title="1.2 文件追加、写入、同步"></a>1.2 文件追加、写入、同步</h4><p>propagate()函数的作用是将命令传播给AOF以及slave中（slave是Redis集群部分的内容），propagate()将命令传播到AOF中是通过调用feedAppendOnlyFile()函数实现的，在调用该函数之前，首先需要检查AOF机制是否已开启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* src/server.c/propagate() */</span>  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">propagate</span><span class="hljs-params">(struct redisCommand *cmd, <span class="hljs-keyword">int</span> dbid, robj **argv, <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;  <br> <span class="hljs-keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)  <br>     feedAppendOnlyFile(cmd,dbid,argv,argc);  <br>&#125; <br></code></pre></td></tr></table></figure><p>feedAppendOnlyFile()位于src/aof.c中，该函数将命令追加至aof_buf中，如果正在执行AOF重写，还需要将其追加到重写缓冲区中，具体实现过程包括以下四个步骤：</p><ol><li>使用 SELECT 命令，显式设置数据库，确保之后的命令被设置到正确的数据库；</li><li>将命令和命令参数还原为协议格式；</li><li>将命令追加到aof_buf中（使用函数sdscatlen()实现，该函数为Redis自定义的，针对sds结构实现的追加函数，位于src/sds.c中）；</li><li>如果BGREWRITEAOF正在进行，还需要将命令追加到重写缓存中（使用函数aofRewriteBufferAppend()实现，位于src/aof.c中）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Append to the AOF buffer. This will be flushed on disk just before </span><br><span class="hljs-comment"> * of re-entering the event loop, so before the client will get a </span><br><span class="hljs-comment"> * positive reply about the operation performed. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_state == AOF_ON)  <br>server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));  <br><span class="hljs-comment">/* If a background append only file rewriting is in progress we want to </span><br><span class="hljs-comment"> * accumulate the differences between the child DB and the current one </span><br><span class="hljs-comment"> * in a buffer, so that when the child process will do its work we </span><br><span class="hljs-comment"> * can append the differences to the new append only file. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>)  <br>aofRewriteBufferAppend((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)buf,sdslen(buf));<br></code></pre></td></tr></table></figure><p>AOF文件的写入和同步采用的是src/aof.c/flushAppendOnlyFile函数。该函数在src/server.c/beforeSleep中会被调用，而beforeSleep函数是在处理client事件之前执行的（事件循环函数aeMain先执行beforesleep，然后执行aeProcessEvents），因此，server.aof_buf中的值会在向client发送响应之前刷新到磁盘上。</p><p>flushAppendOnlyFile(int force)函数的具体实现过程中，根据不同的同步策略以及后台是否有正在进行fsync操作，共分为以下几种情况：</p><ol><li>判断是否写入，同步策略为everysecond（server.aof_fsync == AOF_FSYNC_EVERYSEC），且没有要求强制写入（!force），且有fsync正在后台执行：<ul><li>之前没有推迟过write操作，则记录下时间，直接返回（如果此时强制执行write的话，服务器主线程将阻塞在write上面）；</li><li>之前推迟过write操作，但推迟时间&lt;2秒，直接返回；</li><li>推迟时间&gt;=2秒，不返回，继续执行。</li></ul></li><li>执行写入操作，调用aofWrite函数</li><li>判断是否同步：<ul><li>同步策略为always（server.aof_fsync == AOF_FSYNC_ALWAYS），执行同步操作（调用aof_fsync函数，在Linux系统，该函数使用fdatasync实现，在其他系统中，使用fsync实现）。</li><li>同步策略为everysecond，且距离上次写操作已超过1秒，且没有fsync在后台执行，则后台执行同步操作（调用aof_background_fsync函数）。</li></ul></li></ol><hr><h3 id="2-数据还原"><a href="#2-数据还原" class="headerlink" title="2 数据还原"></a>2 数据还原</h3><p>Redis启动之后，在src/server.c/main()函数中调用loadDataFromDisk()，当AOF为开启状态时，该函数会继续调用src/aof.c/loadAppendOnlyFile()，在该函数中会通过创建伪客户端的方式，遍历执行AOF文件的命令，还原数据库状态。</p><hr><h3 id="3-AOF重写"><a href="#3-AOF重写" class="headerlink" title="3 AOF重写"></a>3 AOF重写</h3><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由server.c/serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等；</li><li>清理数据库中的过期键值对；</li><li>关闭和清理连接失效的客户端；</li><li>触发BGSAVE或者AOF重写，并处理之后由BGSAVE和AOF重写引发的子进程停止。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每秒调用server.hz次，直到服务器关闭为止。</p><h4 id="3-1-BGSAVE和BGREWRITEAOF的触发"><a href="#3-1-BGSAVE和BGREWRITEAOF的触发" class="headerlink" title="3.1 BGSAVE和BGREWRITEAOF的触发"></a>3.1 BGSAVE和BGREWRITEAOF的触发</h4><p>在serverCron()函数中与Redis持久化相关的检查以及处理流程如下图所示，具体实现包括：</p><p><img src="/img/article/Redis/image-20200607224305949.png" alt="serverCron中相关操作流程"></p><ul><li>如果BGSAVE和BGREWRITEAOF都没有在执行，但是有一个BGREWRITEAOF在等待（server.aof_rewrite_scheduled），那么执行BGREWRITEAOF（调用函数src/aof.c/rewriteAppendOnlyFileBackground）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Start a scheduled AOF rewrite if this was requested by the user while </span><br><span class="hljs-comment"> * a BGSAVE was in progress. */</span>  <br><span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;  <br>server.aof_rewrite_scheduled) &#123;  <br>rewriteAppendOnlyFileBackground();  <br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>如果BGSAVE和BGREWRITEAOF都没有在执行，而且也没有BGREWRITEAOF在等待，那么检查是否需要执行它们<ul><li>BGSAVE：检查m秒内是否发生了超过n次的变化（对应于配置文件中的save m n），BGSAVE操作由函数src/rdb.c/rdbSaveBackground实现</li><li>BGREWRITEAOF：<ul><li>当前AOF文件大小大于执行 BGREWRITEAOF 所需的最小大小，即server.aof_rewrite_min_size</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-perc）</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Trigger an AOF rewrite if needed */</span>  <br><span class="hljs-keyword">if</span> (server.rdb_child_pid == <span class="hljs-number">-1</span> &amp;&amp; server.aof_child_pid == <span class="hljs-number">-1</span> &amp;&amp;  <br>    server.aof_rewrite_perc &amp;&amp;  <br>    server.aof_current_size &gt; server.aof_rewrite_min_size)  &#123;  <br>    <span class="hljs-comment">// 上一次完成 AOF 写入之后，AOF 文件的大小  </span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = server.aof_rewrite_base_size ?  <br>                 server.aof_rewrite_base_size : <span class="hljs-number">1</span>;  <br><span class="hljs-comment">// AOF 文件当前的体积相对于 base 的体积的百分比  </span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> growth = (server.aof_current_size*<span class="hljs-number">100</span>/base) - <span class="hljs-number">100</span>;  <br><span class="hljs-comment">// 如果增长体积的百分比超过了 growth ，那么执行 BGREWRITEAOF  </span><br><span class="hljs-keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123; <br>    rewriteAppendOnlyFileBackground();  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>如果存在BGSAVE或者BGREWRITEAOF在执行，则检查其是否已经执行完毕，并处理因此而引发的子进程停止</li><li>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写人的数据，那么serverCron会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync </span><br><span class="hljs-comment"> * completed. */</span>  <br><span class="hljs-keyword">if</span> (server.aof_flush_postponed_start)   <br> flushAppendOnlyFile(<span class="hljs-number">0</span>);  <br></code></pre></td></tr></table></figure><p>在serverCron函数中会通过检查BGREWRITEAOF的两个自动触发条件来执行AOF重写，但除此之外，用户还可以通过在客户端输入bgwriteaof命令来手动触发AOF重写。与其他命令的处理流程相同，bgwriteaof命令对应的命令处理函数为aof.c/bgrewriteaofCommand()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bgrewriteaofCommand</span><span class="hljs-params">(client *c)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (server.aof_child_pid != <span class="hljs-number">-1</span>) &#123;  <br>        addReplyError(c,<span class="hljs-string">&quot;Background AOF rewriting already in progress&quot;</span>);  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (server.rdb_child_pid != <span class="hljs-number">-1</span>) &#123;  <br>    server.aof_rewrite_scheduled = <span class="hljs-number">1</span>;  <br>    addReplyStatus(c,<span class="hljs-string">&quot;Background append only file rewriting scheduled&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rewriteAppendOnlyFileBackground() == C_OK) &#123;  <br>    addReplyStatus(c,<span class="hljs-string">&quot;Background append only file rewriting started&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>    addReply(c,shared.err);  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>在该函数中，AOF重写也是通过调用rewriteAppendOnlyFileBackground函数来实现的。但当有BGSAVE在执行时（server.rdb_child_pid != -1），BGREWRITEAOF会等待（server.aof_rewrite_scheduled = 1），如前文所述，等待的BGREWRITEAOF会在serverCron函数中被执行。</p><h4 id="3-2-AOF重写的实现"><a href="#3-2-AOF重写的实现" class="headerlink" title="3.2 AOF重写的实现"></a>3.2 AOF重写的实现</h4><p>AOF重写是依靠rewriteAppendOnlyFileBackground函数实现的，该函数的处理过程包括：</p><ol><li>使用fork创建一个子进程；</li><li>子进程调用aof.c/rewriteAppendOnlyFile函数在一个临时文件里写入能够反映当前db状态的数据和命令，此时父进程会把这段时间内执行的能够改变当前db数据的命令放到重写缓冲区中；</li><li>当子进程退出时，父进程收到信号，将上面的重写缓冲区中的数据flush到临时文件中，然后将临时文件rename成新的aof文件。</li></ol><p>子进程调用rewriteAppendOnlyFile函数后，在该函数中会继续调用实际的重写函数aof.c/rewriteAppendOnlyFileRio，该函数遍历db中的每条数据，取出键，取出值，然后根据值的类型选择适当的命令来进行保存，然后写入并同步AOF临时文件中。</p><p>在serverCron函数中，会周期性的检查BGREWRITEAOF子进程是否已退出，当父进程收到退出信号后，会调用aof.c/backgroundRewriteDoneHandler函数完成后续处理，包括：</p><ol><li>调用aof.c/aofRewriteBufferWrite函数，将累计的AOF重写缓冲区的内容追加到AOF临时文件中；</li><li>将AOF 临时文件rename，替换现有的AOF文件。</li></ol><p>参考内容：《Redis设计与实现》，黄健宏著</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持久化</tag>
      
      <tag>AOF</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Redis] Redis的数据持久化机制</title>
    <link href="/2021/07/04/Redis-AOF-RDB/"/>
    <url>/2021/07/04/Redis-AOF-RDB/</url>
    
    <content type="html"><![CDATA[<p>Redis作为一种高性能的内存数据库，将全部数据储存在内存当中，因此一旦发生服务器宕机或系统崩溃，存储的数据就会全部丢失。为了解决这一问题，Redis提供RDB和AOF两种持久化机制，将数据同步到磁盘中。当系统或服务器重启时，利用持久化文件即可恢复数据，有效的避免了数据丢失问题。</p><span id="more"></span><hr><h3 id="1-RDB持久化"><a href="#1-RDB持久化" class="headerlink" title="1 RDB持久化"></a>1 RDB持久化</h3><p>RDB持久化方式是通过快照（snapshotting）完成的，当符合一定条件时，redis会自动将内存中所有数据以二进制方式生成一份副本并存储在硬盘上。当redis重启时，redis会读取RDB持久化生成的二进制文件进行数据恢复。</p><h4 id="1-1-RDB持久化的触发条件"><a href="#1-1-RDB持久化的触发条件" class="headerlink" title="1.1 RDB持久化的触发条件"></a>1.1 RDB持久化的触发条件</h4><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><p>save命令触发</p><p>客户端执行save命令，该命令强制redis执行快照，这时候redis处于阻塞状态，不会响应任何其他客户端发来的请求，直到RDB快照文件执行完毕，所以请慎用。</p></li><li><p>bgsave命令触发</p><p>bgsave，即后台保存，当执行bgsave命令时，redis会fork出一个子进程来执行快照生成操作，需要注意的redis是在fork子进程这个简短的时间redis是阻塞的，当子进程创建完成以后redis继续响应客户端请求。执行过程如下图所示：</p></li></ul><p><img src="/img/article/Redis/RDB%E6%8C%81%E4%B9%85%E5%8C%96bgsave%E8%BF%87%E7%A8%8B.jpg" alt="RDB持久化bgsave过程"></p><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p><p>自动触发实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。</p><p>除了save m n以外，还有一些其他情况会触发bgsave， 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点。执行shutdown命令时，也会自动执行rdb持久化。</p><h4 id="1-2-RDB持久化的优缺点"><a href="#1-2-RDB持久化的优缺点" class="headerlink" title="1.2 RDB持久化的优缺点"></a>1.2 RDB持久化的优缺点</h4><ul><li>优点：<ol><li>RDB是一个非常紧凑的文件，体积小，易于传输，适合灾难恢复。</li><li>RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘I/O操作。</li><li>RDB在恢复大数据集时的速度比AOF的恢复速度要快。</li></ol></li><li>缺点：<ol><li>RDB是一个快照过程，无法完整的保存所以数据，尤其在数据量比较大时候，一旦出现故障丢失的数据将更多。</li><li>RDB需要fork子进程将内容持久化在磁盘上。如果数据集很大，fork可能很耗时，并且如果数据集很大且CPU性能不佳，则可能导致Redis停止服务几毫秒甚至一秒钟。AOF机制也需要fork，但可以调整重写日志的频率。</li></ol></li></ul><hr><h3 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2 AOF持久化"></a>2 AOF持久化</h3><p>除了RDB持久化功能外，Redis还提供了AOF持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><h4 id="2-1-AOF持久化的实现"><a href="#2-1-AOF持久化的实现" class="headerlink" title="2.1 AOF持久化的实现"></a>2.1 AOF持久化的实现</h4><p>AOF 持久化功能的实现可以分为命令追加，文件写入，文件同步三个步骤。</p><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。其中aof_buf的定义位于redisServer结构体中。</p><h5 id="AOF文件的同步和写入"><a href="#AOF文件的同步和写入" class="headerlink" title="AOF文件的同步和写入"></a>AOF文件的同步和写入</h5><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里，所以在服务器每次结束一个事件循环之前，他都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和同步到AOF文件中。</p><p>针对flushAppendOnlyFile函数的行为，redis提供了三种同步策略，由配置参数appendfsync来决定，各个不同值产生的行为如下所示：</p><ul><li>everysec：将aof_buf 缓冲区中的所有内容写入到AOF 文件，如果上次同步AOF 文件的时间距离现在超过一秒钟，那么再次对AOF 文件进行同步，并且这个同步操作是由一个专门负责执行的。</li><li>always：将aof_buf 缓冲区的所有内容写入并同步到AOF 文件中。</li><li>no：将aof_buf 缓冲区的所有内容写入到AOF 文件中，但并不对AOF 文件进行同步，合适同步由操作系统决定。</li></ul><p>从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失1秒的命令数据。这是折中的方案，兼顾性能和数据安全，也是redis的默认配置。</p><p>always模式在每次写操作后都调用fsync方法强制内核将数据写入到aof文件。这种情况下虽然数据比较安全，但是因为每次写操作都会同步到AOF文件中，所以在性能上会有影响，同时由于频繁的IO操作，硬盘的使用寿命会降低。</p><p>no模式下的同步交给操作系统write函数去执行，这种情况下，AOF文件写入速度是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据。</p><h4 id="2-2-AOF文件的载入与数据还原"><a href="#2-2-AOF文件的载入与数据还原" class="headerlink" title="2.2 AOF文件的载入与数据还原"></a>2.2 AOF文件的载入与数据还原</h4><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。Redis读取AOF文件并还原数据库的详细步骤如下图所示。</p><p><img src="/img/article/Redis/AOF%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E8%BF%87%E7%A8%8B.jpg" alt="AOF文件载入过程"></p><p>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和网络连接的客户端执行命令的效果完全一样。</p><h4 id="2-3-AOF重写"><a href="#2-3-AOF重写" class="headerlink" title="2.3 AOF重写"></a>2.3 AOF重写</h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，同时使用AOF文件来进行数据还原所需的时间也越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h5 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h5><p>AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><p>假设服务器对某一个key执行了多个写命令，那么服务器为了保存该key的当前状态，必须将这些写命令全部写入AOF文件中。如果服务器想要用尽量少的命令来记录该key的状态，最简单高效的办法不是去读取和分析现有AOF文件的内容，而是直接从数据库中读取该key对应的value值，然后用一条写命令命令来代替原有的多个写命令即可，这就是AOF重写功能的实现原理。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。在Redis4.0版本中，AOF_REWRITE_ITEMS_PER_CMD常量的值为64。</p><h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用AOF重写函数的话，那么在重写期间，服务期将无法处理客户端发来的命令请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>但子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区（aof_rewrite_buf），这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>AOF文件触发条件可分为手动触发和自动触发：</p><ul><li>手动触发：客户端执行bgrewriteaof命令。</li><li>自动触发：自动触发通过以下两个配置协作生效：<ol><li>uto-aof-rewrite-min-size: AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64MB。</li><li>auto-aof-rewrite-percentage：当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。</li></ol></li></ul><p>每次当serverCron（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：</p><ul><li>没有BGSAVE命令（RDB持久化）/AOF持久化在执行；</li><li>没有BGREWRITEAOF在进行；</li><li>当前AOF文件大小要大于server.aof_rewrite_min_size的值；</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（auto-aof-rewrite-perc）<br>整个AOF后台重写过程如下所示：</li></ul><p><img src="/img/article/Redis/AOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.jpg" alt="AOF后台重写过程"></p><ol><li>开始bgrewriteaof</li><li>主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。</li><li>主进程fork完子进程继续接受客户端请求，此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区aof_rewrite_buf。</li><li>子进程通过内存快照，按照命令重写策略写入到新的AOF文件。<ul><li>子进程写完新的AOF文件后，向主进程发信号。</li><li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li></ul></li><li>对新的AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><h4 id="2-4-AOF持久化的优缺点"><a href="#2-4-AOF持久化的优缺点" class="headerlink" title="2.4 AOF持久化的优缺点"></a>2.4 AOF持久化的优缺点</h4><ul><li>优点：<ol><li> 更高的数据安全性，同时有不同的同步策略</li><li> AOF包含一个格式清晰、易于理解的日志文件记录所有的修改操作。</li><li> AOF机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。同时Redis还提供redis-check-aof工具来解决数据一致性的问题。</li></ol></li><li>缺点：<ol><li> 数据文件体积较大，即使有重写机制，但是在相同的数据集情况下，AOF文件通常比RDB文件大。</li><li> 相对RDB方式，AOF模式的恢复速度慢于RDB。</li><li> 由于频繁地将命令同步到文件中，AOF持久化对性能的影响相对RDB较大，但仍在一个可以接受的范围内。</li></ol></li></ul><hr><h3 id="3-RDB-AOF混合持久化"><a href="#3-RDB-AOF混合持久化" class="headerlink" title="3 RDB-AOF混合持久化"></a>3 RDB-AOF混合持久化</h3><p>从redis4.0开始，添加了新的混合持久化方式，这里介绍的混合持久化就是同时结合RDB持久化以及AOF持久化混合写入AOF文件。这样做的好处是可以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据，缺点是AOF里面的RDB部分就是压缩格式不再是AOF格式，可读性差。</p><p>混合持久化同样也是通过bgrewriteAOF完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入AOF文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说，新的AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。</p><p>当我们开启了混合持久化时，启动redis依然优先加载AOF文件，AOF文件加载可能有两种情况如下：</p><ul><li>AOF文件开头是RDB的格式，先加载RDB内容再加载剩余的AOF。</li><li>AOF文件开头不是RDB的格式，直接以AOF格式加载整个文件。</li></ul><p>参考内容：<br>[1]《redis系列–redis4.0深入持久化》，<a href="https://www.cnblogs.com/wdliu/p/9377278.html">https://www.cnblogs.com/wdliu/p/9377278.html</a><br>[2]《Redis设计与实现》，黄健宏著</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持久化</tag>
      
      <tag>RDB</tag>
      
      <tag>AOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Paper] Pangolin: A Fault-Tolerant Persistent Memory Programming Library</title>
    <link href="/2021/07/03/Pangolin/"/>
    <url>/2021/07/03/Pangolin/</url>
    
    <content type="html"><![CDATA[<p>论文发表于2019年USENIX Annual Technical Conference(ATC)中，提出了一种能实现fault tolerance的，基于DAX-map的NVMM编程库——Pangolin。论文出自加州大学圣地亚哥分校的Non-Volatile Systems Laboratory(NVSL)。该实验室专注于新型内存技术的研究，近年来在ATC、FAST、ASPLOS等A类会议发表多篇高水平论文，包括基于非易失性内存的测试框架、文件系统、编程库等多个方向。</p><p>非易失性内存(NVMM)的一个重要特征就是支持DAX模式，在该模式下，实现崩溃一致性(Crash consistency)和容错(Fault tolerance)都十分必要，近年来已经有诸多实验团队针对Crash consistency提出解决方法，但对于Fault tolerance的研究还比较稀少。在这样的背景下，论文提出了一种能实现fault tolerance的，基于DAX-map的NVMM编程库——Pangolin，用于应用程序在NVMM中构建复杂的数据结构。Pangolin结合了校验和(checksum)、奇偶校验(parity)和微缓冲(micro-buffer)三种技术，能够同时避免media error和software bug带来的损害，并支持自动检测和在线恢复。与现阶段支持fault tolerance的NVMM编程库相比，Pangolin使用了的很小的存储开销，达到了类似的性能。</p><p>现阶段的NVM编程库libpmemobj通过副本(replication)的方法来实现fault tolerance，但这样会带来100%的空间开销，为了减少存储开销，Pangolin提出了下图所示的数据保护模式：</p><p><img src="/img/article/Paper/1.png"></p><p>对于一个NVMM pool，其中pool和zone的元数据PM和ZM，以及Log区域仍然采用replication的方式进行容错，因为这一部分所占的存储空间很小（对于1GB的pool，只占用0.1%的存储空间）。对于chunk区域，在逻辑上将其组织为二维数组的形式，最后一行作为parity data进行奇偶检验，chunk的元数据CM和object data都通过parity来进行数据容错。同时，Pangolin还在每个object header中开辟了32 bit的区域存放checksum，进行object data的错误检测。</p><p>为了降低更新checksum和parity所带来的的一致性挑战，Pangolin引入了micro-buffer。当需要修改一个PMEM中的object时，需要在micro-buffer中做一个object的shadow copy，对object的修改将在DRAM中进行，修改完成后重新计算checksum，将checksum和修改操作记录到Log中，随后进行parity的更新操作，当以上步骤都完成以后，将修改后的object写回PMEM中。一次完整的流程如下图所示：</p><p><img src="/img/article/Paper/2.png"></p><p>采用micro-buffer除了可以降低更新一致性的复杂性以外，还可以避免缓冲区溢出，悬垂指针等软件bug对NVMM带来的影响。同时，由于micro-buffer位于DRAM中，可以借鉴一些内存调试工具的思想来实现更强的数据保护，例如，Pangolin在每个micro-buffer的header中插入了一个64-bit的canary，在将object写回之前，通过验证其完整性提供对NVMM的保护。</p><p>由于XOR运算的可交换性，在进行parity更新时，可以实现较为简单的增量更新，单个object的修改带来的parity更新过程如下图所示：</p><p><img src="/img/article/Paper/3.png"></p><p>当一个Range Column中的多个object同时进行更新时，就带来了parity update的一致性挑战，同时由于Atomic XOR要慢于Vectorized XOR，为了保证更新一致性同时兼顾计算效率，论文引入了一种细粒度锁——parity range-locks。对于Small updates (&lt; 8KB)，共享range-lock，采用atomic XOR instructions并行更新parity；对于Large updates (≥ 8KB)，独占range-lock，采用Vectorized XOR串行更新parity。</p><p>与libpmemobj的replication方式相比，Pangolin使用更小的存储空间实现了类似的性能，同时保证了crash consistency，除此之外还支持software级别的错误检测和在线恢复。但在容错度方面，Pangolin仅支持任意位置的单4KB page的错误，或者位于不同Range Column的object错误，这是由parity本身的性质导致的，为了提高容错度，就需要减少行数，增加列数以减少错误overlap的概率，但过多的列数同样会增加计算parity的开销。除此之外，Pangolin仅支持多线程同时修改不同的object，不支持多线程同时修改同一个object，这同时也是libpmemobj存在的问题。</p><p>论文链接：<a href="https://www.usenix.org/conference/atc19/presentation/zhang-lu">https://www.usenix.org/conference/atc19/presentation/zhang-lu</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容错</tag>
      
      <tag>PM</tag>
      
      <tag>NVM</tag>
      
      <tag>PMDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/03/hello-world/"/>
    <url>/2021/07/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
