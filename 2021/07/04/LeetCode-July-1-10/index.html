

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/favicon.png">
  <link rel="icon" href="/img/icon/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="
July 1 - LCP 07. 传递信息；
July 2 - 1833. 雪糕的最大数量；
July 3 - 根据字符出现频率排序；
July 4 - 645. 错误的集合；
July 5 - 726. 原子的数量；
July 6 - 1418. 点菜展示表；
July 7 - 1711. 大餐计数；
July 8 - 930. 和相同的二元子数组；
July 9 - 面试题 17.10. 主">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>[LeetCode] 每日一题 July 1~10 - 老君的借火岩</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>老君的借火岩</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/wenzhang.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="[LeetCode] 每日一题 July 1~10">
              
                [LeetCode] 每日一题 July 1~10
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-04 17:11" pubdate>
        2021年7月4日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">[LeetCode] 每日一题 July 1~10</h1>
            
            <div class="markdown-body">
              <ul>
<li>July 1 - LCP 07. 传递信息；</li>
<li>July 2 - 1833. 雪糕的最大数量；</li>
<li>July 3 - 根据字符出现频率排序；</li>
<li>July 4 - 645. 错误的集合；</li>
<li>July 5 - 726. 原子的数量；</li>
<li>July 6 - 1418. 点菜展示表；</li>
<li>July 7 - 1711. 大餐计数；</li>
<li>July 8 - 930. 和相同的二元子数组；</li>
<li>July 9 - 面试题 17.10. 主要元素；</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="July-1-LCP-07-传递信息"><a href="#July-1-LCP-07-传递信息" class="headerlink" title="July 1 - LCP 07. 传递信息"></a>July 1 - LCP 07. 传递信息</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p>
<ul>
<li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li>
<li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li>
<li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li>
</ul>
<p>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：n = <span class="hljs-number">5</span>, relation = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>说明：信息从小 A 编号 <span class="hljs-number">0</span> 处开始，经 <span class="hljs-number">3</span> 轮传递，到达编号 <span class="hljs-number">4</span>。共有 <span class="hljs-number">3</span> 种方案，分别是 <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：n = <span class="hljs-number">3</span>, relation = [[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">限制：<br>    <span class="hljs-number">2</span> &lt;= n &lt;= <span class="hljs-number">10</span><br>	<span class="hljs-number">1</span> &lt;= k &lt;= <span class="hljs-number">5</span><br>	<span class="hljs-number">1</span> &lt;= relation.length &lt;= <span class="hljs-number">90</span>, 且 relation[i].length == <span class="hljs-number">2</span><br>	<span class="hljs-number">0</span> &lt;= relation[i][<span class="hljs-number">0</span>],relation[i][<span class="hljs-number">1</span>] &lt; n 且 relation[i][<span class="hljs-number">0</span>] != relation[i][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>



<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h5><p>可以把传信息的关系看成有向图，每个玩家对应一个节点，每个传信息的关系对应一条有向边。如果 x 可以向 y 传信息，则对应从节点 x 到节点 y 的一条有向边。寻找从编号 0 的玩家经过 k 轮传递到编号 n−1 的玩家处的方案数，等价于在有向图中寻找从节点 0 到节点 n−1 的长度为 k 的路径数，同一条路径可以重复经过同一个节点。</p>
<p>可以使用深度优先搜索计算方案数。从节点 0 出发做深度优先搜索，每一步记录当前所在的节点以及经过的轮数，当经过 k 轮时，如果位于节点 n−1，则将方案数加 1。搜索结束之后，即可得到总的方案数。</p>
<p>时间复杂度：O(n^k)。最多需要遍历 k 层，每层遍历最多有 O(n) 个分支。</p>
<p>空间复杂度：O(n+m+k)。其中 m 为 relation 数组的长度。空间复杂度主要取决于图的大小和递归调用栈的深度，保存有向图信息所需空间为 O(n+m)，递归调用栈的深度不会超过 k。</p>
<h5 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h5><p>也可以使用广度优先搜索计算方案数。从节点 0 出发做广度优先搜索，当遍历到 k 层时，如果位于节点 n−1，则将方案数加 1。搜索结束之后，即可得到总的方案数。</p>
<h5 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h5><p>这道题是计数问题，可以使用动态规划的方法解决。</p>
<p>定义动态规划的状态 dp[i][j]为经过 i 轮传递到编号 j 的玩家的方案数，其中 0≤i≤k，0≤j&lt;n。</p>
<p>由于从编号 0 的玩家开始传递，当 i=0 时，一定位于编号 0 的玩家，不会传递到其他玩家，因此动态规划的边界情况如下：</p>
<p><img src="/img/article/LeetCode/image-20210701213904825.png" srcset="/img/loading.gif" lazyload></p>
<p>对于传信息的关系 [src,dst]，如果第 i轮传递到编号 src 的玩家，则第 i+1 轮可以从编号 src 的玩家传递到编号 dst 的玩家。因此在计算 dp[i+1][dst] 时，需要考虑可以传递到编号 dst 的所有玩家。由此可以得到动态规划的状态转移方程，其中 0≤i&lt;k：</p>
<p><img src="/img/article/LeetCode/image-20210701214033003.png" srcset="/img/loading.gif" lazyload></p>
<p>最终得到 dp[k][n−1] 即为总的方案数。</p>
<p>时间复杂度：O(km)。其中 m为 relation 数组的长度。</p>
<p>空间复杂度是 O(kn)。由于当 i&gt;0 时，dp[i][] 的值只和dp[i−1][] 的值有关，因此可以将二维数组变成一维数组，将空间复杂度优化到 O(n)。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//动态规划</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : relation) &#123;<br>                <span class="hljs-keyword">int</span> src = edge[<span class="hljs-number">0</span>], dst = edge[<span class="hljs-number">1</span>];<br>                dp[i + <span class="hljs-number">1</span>][dst] += dp[i][src];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//动态规划空间复杂度优化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relation, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : relation) &#123;<br>                <span class="hljs-keyword">int</span> src = edge[<span class="hljs-number">0</span>], dst = edge[<span class="hljs-number">1</span>];<br>                next[dst] += dp[src];<br>            &#125;<br>            dp = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析 | 菜鸟教程 (runoob.com)</a></p>
<hr>
<h3 id="July-2-1833-雪糕的最大数量"><a href="#July-2-1833-雪糕的最大数量" class="headerlink" title="July 2 - 1833. 雪糕的最大数量"></a>July 2 - 1833. 雪糕的最大数量</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p>
<p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>排序 + 贪心</p>
<p>对数组costs 排序，然后按照从小到大的顺序遍历数组元素，对于每个元素，如果该元素不超过剩余的硬币数，则将硬币数减去该元素值，表示购买了这支雪糕，当遇到一个元素超过剩余的硬币数时，结束遍历，此时购买的雪糕数量即为可以购买雪糕的最大数量。</p>
<p>时间复杂度：O(nlogn)，其中 n 是数组 costs 的长度。对数组排序的时间复杂度是 O(nlogn)，遍历数组的时间复杂度是O(n)，因此总时间复杂度是O(nlogn)。</p>
<p>空间复杂度：O(logn)，其中 n 是数组 costs 的长度。空间复杂度主要取决于排序使用的额外空间。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxIceCream</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; costs, <span class="hljs-keyword">int</span> coins)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(costs.<span class="hljs-built_in">begin</span>(),costs.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a : costs)&#123;<br>            <span class="hljs-keyword">if</span>(a&lt;=coins)&#123;<br>                i++;<br>                coins-=a;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<hr>
<h3 id="July-3-根据字符出现频率排序"><a href="#July-3-根据字符出现频率排序" class="headerlink" title="July 3 - 根据字符出现频率排序"></a>July 3 - 根据字符出现频率排序</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入:<br><span class="hljs-string">&quot;tree&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;eert&quot;</span><br><br>解释:<br><span class="hljs-string">&#x27;e&#x27;</span>出现两次，<span class="hljs-string">&#x27;r&#x27;</span>和<span class="hljs-string">&#x27;t&#x27;</span>都只出现一次。<br>因此<span class="hljs-string">&#x27;e&#x27;</span>必须出现在<span class="hljs-string">&#x27;r&#x27;</span>和<span class="hljs-string">&#x27;t&#x27;</span>之前。此外，<span class="hljs-string">&quot;eetr&quot;</span>也是一个有效的答案。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入:<br><span class="hljs-string">&quot;Aabb&quot;</span><br><br>输出:<br><span class="hljs-string">&quot;bbAa&quot;</span><br><br>解释:<br>此外，<span class="hljs-string">&quot;bbaA&quot;</span>也是一个有效的答案，但<span class="hljs-string">&quot;Aabb&quot;</span>是不正确的。<br>注意<span class="hljs-string">&#x27;A&#x27;</span>和<span class="hljs-string">&#x27;a&#x27;</span>被认为是两种不同的字符。<br></code></pre></td></tr></table></figure>



<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题目要求将给定的字符串按照字符出现的频率降序排序，因此需要首先遍历字符串，统计每个字符出现的频率，然后每次得到频率最高的字符，生成排序后的字符串。</p>
<p>可以使用哈希表记录每个字符出现的频率，将字符去重后存入列表，再将列表中的字符按照频率降序排序。</p>
<p>生成排序后的字符串时，遍历列表中的每个字符，则遍历顺序为字符按照频率递减的顺序。对于每个字符，将该字符按照出现频率拼接到排序后的字符串。例如，遍历到字符 c，该字符在字符串中出现了 freq 次，则将 freq 个字符 c 拼接到排序后的字符串。</p>
<p>时间复杂度：O(n+klogk)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数，这道题中 s 只包含大写字母、小写字母和数字，因此 k=26+26+10=62。遍历字符串统计每个字符出现的频率需要 O(n) 的时间。将字符按照出现频率排序需要 O(klogk) 的时间。生成排序后的字符串，需要遍历 k 个不同字符，需要 O(k) 的时间，拼接字符串需要 O(n) 的时间。因此总时间复杂度是 O(n+klogk+k+n)=O(n+klogk)。</p>
<p>空间复杂度：O(n+k)，其中 n 是字符串 s 的长度，k 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于哈希表、列表和生成的排序后的字符串。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;a, pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;freq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m:s)&#123;<br>            freq[m]++;<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;&gt;vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:freq)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(n);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),cmp);<br>        string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:vec)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k.second;i++)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(k.first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>reference to non-static member function must be called</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010982765/article/details/79021426">错误：reference to non-static member function must be called_initHeart的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/AnnieKim/archive/2011/12/04/2275589.html">恼人的函数指针（二）：指向类成员的指针 - AnnieKim - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xs18952904/article/details/81463822">C++中 sort() 的使用_LucienShui-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sevenjoin/article/details/81937695">C++ pair的基本用法总结（整理）_sevenjoin的博客-CSDN博客_c++ pair</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hk2291976/article/details/51037095">关联容器：unordered_map详细介绍（附可运行代码）_Voidsky-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6826.html">C++ STL vector添加元素（push_back()和emplace_back()）详解 (biancheng.net)</a></p>
<hr>
<h3 id="July-4-645-错误的集合"><a href="#July-4-645-错误的集合" class="headerlink" title="July 4 - 645. 错误的集合"></a>July 4 - 645. 错误的集合</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。</p>
<p>给定一个数组 nums 代表了集合 S 发生错误后的结果。</p>
<p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2,4]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,3,4,6,5]</span><br>输出：<span class="hljs-comment">[3,1]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,5,3,2</span>,<span class="hljs-number">2,7,6,4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure>



<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：排序</strong></p>
<p>将数组排序之后，比较每对相邻的元素，即可找到错误的集合。</p>
<p>寻找重复的数字较为简单，如果相邻的两个元素相等，则该元素为重复的数字。</p>
<p>寻找丢失的数字相对复杂，可能有以下两种情况：</p>
<ul>
<li>如果丢失的数字大于 1 且小于 n，则一定存在相邻的两个元素的差等于 2，这两个元素之间的值即为丢失的数字；</li>
<li>如果丢失的数字是 1 或 n，则需要另外判断。</li>
</ul>
<p>时间复杂度：O(nlogn)，其中 nn 是数组 nums 的长度。排序需要 O(nlogn) 的时间，遍历数组找到错误的集合需要 O(n) 的时间，因此总时间复杂度是 O(nlogn)。</p>
<p>空间复杂度：O(logn)，其中 n 是数组 nums 的长度。排序需要 O(logn) 的空间。</p>
<p><strong>方法二：哈希表</strong></p>
<p>重复的数字在数组中出现 2 次，丢失的数字在数组中出现 0 次，其余的每个数字在数组中出现 1 次。因此可以使用哈希表记录每个元素在数组中出现的次数，然后遍历从 1 到 n 的每个数字，分别找到出现 2 次和出现 0 次的数字，即为重复的数字和丢失的数字。</p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。需要遍历数组并填入哈希表，然后遍历从 1 到 n 的每个数寻找错误的集合。</p>
<p>空间复杂度：O(n)，其中 n 是数组nums 的长度。需要创建大小为 O(n) 的哈希表。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法1，排序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">int</span> curr = nums[i];<br>            <span class="hljs-keyword">if</span>(curr == prev)&#123;<br>                result[<span class="hljs-number">0</span>] = prev;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curr - prev &gt; <span class="hljs-number">1</span>)&#123;<br>                result[<span class="hljs-number">1</span>] = curr - <span class="hljs-number">1</span>;<br>            &#125;<br>            prev = curr;<br>        &#125; <br>        <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>] != n)&#123;<br>            result[<span class="hljs-number">1</span>] = n;<br>        &#125;       <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法2，hash表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;num_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:nums)&#123;<br>            num_map[i]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(num_map[j] == <span class="hljs-number">0</span>)&#123;<br>                result[<span class="hljs-number">1</span>] = j;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num_map[j] == <span class="hljs-number">2</span>)&#123;<br>                result[<span class="hljs-number">0</span>] = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>注意数组边界，前后两个数字相比时，注意后面一个数字不要越界</li>
<li>注意特殊情况，当缺少1或者n时的特殊处理</li>
</ul>
<hr>
<h3 id="July-5-726-原子的数量"><a href="#July-5-726-原子的数量" class="headerlink" title="July 5 - 726. 原子的数量"></a>July 5 - 726. 原子的数量</h3><hr>
<h3 id="July-6-1418-点菜展示表"><a href="#July-6-1418-点菜展示表" class="headerlink" title="July 6 - 1418. 点菜展示表"></a>July 6 - 1418. 点菜展示表</h3><hr>
<h3 id="July-7-1711-大餐计数"><a href="#July-7-1711-大餐计数" class="headerlink" title="July 7 - 1711. 大餐计数"></a>July 7 - 1711. 大餐计数</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。</p>
<p>你可以搭配 任意 两道餐品做一顿大餐。</p>
<p>给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。</p>
<p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：deliciousness = [1,3,5,7,9]<br>输出：4<br>解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。<br>它们各自的美味程度之和分别为<span class="hljs-number"> 4 </span>、8 、8 和<span class="hljs-number"> 16 </span>，都是<span class="hljs-number"> 2 </span>的幂。<br></code></pre></td></tr></table></figure>

<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：deliciousness = [1,1,1,3,3,3,7]<br>输出：15<br>解释：大餐的美味程度组合为<span class="hljs-number"> 3 </span>种 (1,1) ，9 种 (1,3) ，和<span class="hljs-number"> 3 </span>种 (1,7) 。<br></code></pre></td></tr></table></figure>



<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>朴素的解法是遍历数组 deliciousness 中的每对元素，对于每对元素，计算两个元素之和是否等于 2 的幂。该解法的时间复杂度为 O(n^2)，会超出时间限制。</p>
<p>上述朴素解法存在同一个元素被重复计算的情况，因此可以使用哈希表减少重复计算，降低时间复杂度。具体做法是，使用哈希表存储数组中的每个元素的出现次数，遍历到数组 deliciousness 中的某个元素时，在哈希表中寻找与当前元素的和等于 2 的幂的元素个数，然后用当前元素更新哈希表。由于遍历数组时，哈希表中已有的元素的下标一定小于当前元素的下标，因此任意一对元素之和等于 2 的幂的元素都不会被重复计算。</p>
<p>令 maxVal 表示数组 deliciousness 中的最大元素，则数组中的任意两个元素之和都不会超过   maxVal×2。令 maxSum=maxVal×2，则任意一顿大餐的美味程度之和为不超过 maxSum 的某个 2 的幂。</p>
<p>对于某个特定的 2 的幂 sum，可以在 O(n) 的时间内计算数组 deliciousness 中元素之和等于 sum 的元素对的数量。数组 deliciousness 中的最大元素 maxVal 满足 maxVal≤C，其中 C=2^20，则不超过 maxSum 的 2 的幂有 O(logmaxSum)=O(logmaxVal)=O(logC) 个，因此可以在 O(nlogC) 的时间内计算数组 deliciousness 中的大餐数量。</p>
<p>时间复杂度：O(nlogC)，其中 n 是数组 deliciousness 的长度，C 是数组 deliciousness 中的元素值上限，这道题中 C=2^20 。需要遍历数组 deliciousness 一次，对于其中的每个元素，需要 O(logC) 的时间计算包含该元素的大餐数量，因此总时间复杂度是 O(nlogC)。</p>
<p>空间复杂度：O(n)，其中 n 是数组 deliciousness 的长度。需要创建哈希表，哈希表的大小不超过 n。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; deliciousness)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxVal =  *<span class="hljs-built_in">max_element</span>(deliciousness.<span class="hljs-built_in">begin</span>(),deliciousness.<span class="hljs-built_in">end</span>());  <br>        <span class="hljs-keyword">int</span> maxSum = maxVal * <span class="hljs-number">2</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:deliciousness)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sum=<span class="hljs-number">1</span>; sum&lt;=maxSum; sum*=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">int</span> num = map.<span class="hljs-built_in">count</span>(sum-a)? map[sum-a]:<span class="hljs-number">0</span>;<br>                result = (result + num) % MOD;<br>            &#125;<br>            map[a]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sevenjoin/article/details/81943864">C++ map用法总结（整理）_sevenjoin的博客-CSDN博客_c++map</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sword-/p/8036813.html">C++中Vector求最大值最小值 - 西瓜刀刀刀 - 博客园 (cnblogs.com)</a></li>
</ul>
<hr>
<h3 id="July-8-930-和相同的二元子数组"><a href="#July-8-930-和相同的二元子数组" class="headerlink" title="July 8 - 930. 和相同的二元子数组"></a>July 8 - 930. 和相同的二元子数组</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p>
<p><strong>子数组</strong> 是数组的一段连续部分。</p>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,0,1,0,1]</span>, goal = 2<br>输出：4<br>解释：有 4 个满足题目要求的子数组：<span class="hljs-comment">[1,0,1]</span>、<span class="hljs-comment">[1,0,1,0]</span>、<span class="hljs-comment">[0,1,0,1]</span>、<span class="hljs-comment">[1,0,1]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-attr">goal</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>



<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>方法一：哈希表</strong></p>
<p>假设原数组的前缀和数组为 sum，且子数组 (i,j] 的区间和为 goal，那么 sum[j]−sum[i]=goal。因此我们可以枚举 j ，每次查询满足该等式的 i 的数量。</p>
<p>具体地，我们用哈希表记录每一种前缀和出现的次数，假设我们当前枚举到元素 nums[j]，我们只需要查询哈希表中元素 sum[j]−goal 的数量即可，这些元素的数量即对应了以当前 j 值为右边界的满足条件的子数组的数量。最后这些元素的总数量即为所有和为 goal 的子数组数量。</p>
<p>在实际代码中，我们实时地更新哈希表，以防止出现 i≥j 的情况。</p>
<p>时间复杂度：O(n)，其中 n 为给定数组的长度。对于数组中的每个元素，我们至多只需要插入到哈希表中中一次。</p>
<p>空间复杂度：O(n)，其中 n 为给定数组的长度。哈希表中至多只存储 O(n) 个元素。</p>
<p><strong>方法二：滑动窗口</strong></p>
<p>注意到对于方法一中每一个 j，满足 sum[j]−sum[i]=goal 的 i 总是落在一个连续的区间中，i 值取区间中每一个数都满足条件。并且随着 j 右移，其对应的区间的左右端点也将右移，这样我们即可使用滑动窗口解决本题。</p>
<p>具体地，我们令滑动窗口右边界为 right，使用两个左边界 left1 和 left2 表示左区间 [left1 ,left2)，此时有 left2−left1 个区间满足条件。</p>
<p>在实际代码中，我们需要注意 left1≤left2≤right+1，因此需要在代码中限制 left1和 left2 不超出范围。</p>
<p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为给定数组的长度。我们至多只需要遍历一次该数组。</p>
<p>空间复杂度：<em>O</em>(1)，我们只需要常数的空间保存若干变量。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一：哈希表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarraysWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums)&#123;<br>            map[sum]++;<br>            sum += a;<br>            result += map[sum-goal];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法二：滑动窗口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSubarraysWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> goal)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> left1 = <span class="hljs-number">0</span>, left2 = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum1 = <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            sum1 += nums[right];<br>            <span class="hljs-keyword">while</span> (left1 &lt;= right &amp;&amp; sum1 &gt; goal) &#123;<br>                sum1 -= nums[left1];<br>                left1++;<br>            &#125;<br>            sum2 += nums[right];<br>            <span class="hljs-keyword">while</span> (left2 &lt;= right &amp;&amp; sum2 &gt;= goal) &#123;<br>                sum2 -= nums[left2];<br>                left2++;<br>            &#125;<br>            ret += left2 - left1;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="July-9-面试题-17-10-主要元素"><a href="#July-9-面试题-17-10-主要元素" class="headerlink" title="July 9 - 面试题 17.10. 主要元素"></a>July 9 - 面试题 17.10. 主要元素</h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>数组中占比<strong>超过一半</strong>的元素称之为<strong>主要元素</strong>。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。</p>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,2,5,9</span>,<span class="hljs-number">5,9,5,5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,2]</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">输入：<span class="hljs-selector-attr">[2,2,2,3,3,4,4]</span><br>输出：<span class="hljs-selector-tag">-1</span> (元素<span class="hljs-number">2</span>的个数没有超过一半)<br></code></pre></td></tr></table></figure>



<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>由于题目要求时间复杂度 O(n) 和空间复杂度 O(1)，因此符合要求的解法只有 Boyer-Moore 投票算法。</p>
<p>Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。</p>
<p>如果数组为空，则数组中不存在主要元素；</p>
<p>如果数组中剩下的元素都相等，则数组中剩下的元素可能为主要元素。</p>
<p>Boyer-Moore 投票算法的步骤如下：</p>
<p>维护一个候选主要元素 candidate 和候选主要元素的出现次数 count，初始时 candidate 为任意值，count=0；</p>
<p>遍历数组 nums 中的所有元素，遍历到元素 x 时，进行如下操作：</p>
<p>如果 count=0，则将 x 的值赋给 candidate，否则不更新 candidate 的值；</p>
<p>如果 x=candidate，则将 count 加 1，否则将 count 减 1。</p>
<p>遍历结束之后，如果数组 nums 中存在主要元素，则 candidate 即为主要元素，否则 candidate 可能为数组中的任意一个元素。</p>
<p>由于不一定存在主要元素，因此需要第二次遍历数组，验证 candidate 是否为主要元素。第二次遍历时，统计 candidate 在数组中的出现次数，如果出现次数大于数组长度的一半，则 candidate 是主要元素，返回 candidate，否则数组中不存在主要元素，返回 −1。</p>
<p>为什么当数组中存在主要元素时，Boyer-Moore 投票算法可以确保得到主要元素？</p>
<p>在 Boyer-Moore 投票算法中，遇到相同的数则将 count 加 1，遇到不同的数则将 count 减 1。根据主要元素的定义，主要元素的出现次数大于其他元素的出现次数之和，因此在遍历过程中，主要元素和其他元素两两抵消，最后一定剩下至少一个主要元素，此时 candidate 为主要元素，且 count≥1。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通解法O(n),O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;map;<br>        <span class="hljs-keyword">int</span> max = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:nums)&#123;<br>            map[a]++;<br>            <span class="hljs-keyword">if</span>(map[a] &gt; max)&#123;<br>                result = a;<br>                max = map[a];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Boyer-Moore 投票算法 O(n),O(1)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> candidate = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums)&#123;<br>            <span class="hljs-keyword">if</span>((count==<span class="hljs-number">0</span>)&amp;&amp;(a!=candidate))&#123;<br>                candidate=a;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == candidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                count--;<br>            &#125;<br>        &#125;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b:nums)&#123;<br>            <span class="hljs-keyword">if</span>(b==candidate)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count&gt;nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> candidate;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-majority-element-lcci/solution/zhu-yao-yuan-su-by-leetcode-solution-xr1p/">主要元素 - 主要元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/LeetCode/">LeetCode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Hash/">Hash</a>
                    
                      <a class="hover-with-bg" href="/tags/Dynamic-Programming/">Dynamic Programming</a>
                    
                      <a class="hover-with-bg" href="/tags/Greedy/">Greedy</a>
                    
                      <a class="hover-with-bg" href="/tags/Sort/">Sort</a>
                    
                      <a class="hover-with-bg" href="/tags/Boyer-Moore/">Boyer-Moore</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/04/Lintcode-4/">
                        <span class="hidden-mobile">[LintCode] 4 丑数Ⅱ</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        津ICP备20003724号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12011202000392"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>津公网安备12011202000392号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
